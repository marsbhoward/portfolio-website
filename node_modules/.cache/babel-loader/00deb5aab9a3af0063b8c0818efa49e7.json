{"ast":null,"code":"var _jsxFileName = \"/Users/marshoward/Development/code/website/src/components/river/moreInfo.js\";\nimport React, { useLayoutEffect, useState, useEffect } from 'react';\nimport ReactDOM from 'react-dom';\n\nfunction MoreInfo() {\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"moreInfo\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 7,\n      columnNumber: 3\n    }\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"section\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 8,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"h3\", {\n    className: \"subHeader\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 9,\n      columnNumber: 5\n    }\n  }, \"Concept\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 10,\n      columnNumber: 5\n    }\n  }, \"Whenever I'm with family or friends and we decide to watch a movie we never have one in mind. We jump in and out of apps trying to weigh our options and view the trailers, eventually the routine becomes more time consuming than the movie we actually want to enjoy. So I designed this application to consolidate the most popular movies across multiple streaming platforms and streamline the process. From the selected movie\\u2019s page you can view trailers, ratings, and more.\")), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"sketches\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 14,\n      columnNumber: 4\n    }\n  }, /*#__PURE__*/React.createElement(\"img\", {\n    className: \"sketch\",\n    src: require('../../images/riverSketch1.png'),\n    alt: \"sketch\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 15,\n      columnNumber: 5\n    }\n  }), /*#__PURE__*/React.createElement(\"img\", {\n    className: \"sketch\",\n    src: require('../../images/riverSketch2.png'),\n    alt: \"sketch\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 5\n    }\n  }), /*#__PURE__*/React.createElement(\"img\", {\n    className: \"sketch\",\n    src: require('../../images/riverSketch3.png'),\n    alt: \"sketch\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 17,\n      columnNumber: 5\n    }\n  })), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"section\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 19,\n      columnNumber: 4\n    }\n  }, /*#__PURE__*/React.createElement(\"h3\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 20,\n      columnNumber: 5\n    }\n  }, \"Under The Hood\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 21,\n      columnNumber: 5\n    }\n  }, \"For this single page web application (SPA) I utilized Ruby on Rails to build out a database that consists of the streaming service providers, a model for the users and streams, and a web scraper built on Nokogiri to gather the lists of movies from the internet. To form the frontend side of River I used ReactJS + Redux and Thunk. In addition to these I used Auth0 to handle secure logins via email and Facebook.\", /*#__PURE__*/React.createElement(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 25,\n      columnNumber: 6\n    }\n  }), /*#__PURE__*/React.createElement(\"br\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 26,\n      columnNumber: 6\n    }\n  }), \"On the route to collect the necessary info for the movie titles I scraped on the backend, I had to chain multiple fetch requests to collect targeted data from omdbapi.com (an imdb api source) and send that data to YouTube\\u2019s api to gather the movie trailer before patching the collected data back to my backend api.\")));\n}\n\nexport default MoreInfo;","map":{"version":3,"sources":["/Users/marshoward/Development/code/website/src/components/river/moreInfo.js"],"names":["React","useLayoutEffect","useState","useEffect","ReactDOM","MoreInfo","require"],"mappings":";AAAA,OAAOA,KAAP,IAAgBC,eAAhB,EAAiCC,QAAjC,EAA2CC,SAA3C,QAA2D,OAA3D;AACA,OAAOC,QAAP,MAAqB,WAArB;;AAGA,SAASC,QAAT,GAAmB;AAClB,sBACC;AAAK,IAAA,SAAS,EAAE,UAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE;AAAK,IAAA,SAAS,EAAE,SAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACA;AAAI,IAAA,SAAS,EAAE,WAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eADA,eAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oeAFA,CADF,eAOC;AAAK,IAAA,SAAS,EAAC,UAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACC;AAAK,IAAA,SAAS,EAAC,QAAf;AAAwB,IAAA,GAAG,EAAEC,OAAO,CAAC,+BAAD,CAApC;AAAuE,IAAA,GAAG,EAAC,QAA3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IADD,eAEC;AAAK,IAAA,SAAS,EAAC,QAAf;AAAwB,IAAA,GAAG,EAAEA,OAAO,CAAC,+BAAD,CAApC;AAAuE,IAAA,GAAG,EAAC,QAA3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAFD,eAGC;AAAK,IAAA,SAAS,EAAC,QAAf;AAAwB,IAAA,GAAG,EAAEA,OAAO,CAAC,+BAAD,CAApC;AAAuE,IAAA,GAAG,EAAC,QAA3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAHD,CAPD,eAYC;AAAK,IAAA,SAAS,EAAE,SAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBADD,eAEC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kbAIC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAJD,eAKC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IALD,oUAFD,CAZD,CADD;AA0BA;;AACD,eAAeD,QAAf","sourcesContent":["import React, { useLayoutEffect, useState ,useEffect} from 'react';\nimport ReactDOM from 'react-dom'\n\n\nfunction MoreInfo(){\n\treturn(\n\t\t<div className= \"moreInfo\">\n\t \t\t<div className= \"section\"> \n\t\t\t\t<h3 className= \"subHeader\">Concept</h3>\n\t\t\t\t<p>\n\t\t\t\t\tWhenever I'm with family or friends and we decide to watch a movie we never have one in mind. We jump in and out of apps trying to weigh our options and view the trailers, eventually the routine becomes more time consuming than the movie we actually want to enjoy. So I designed this application to consolidate the most popular movies across multiple streaming platforms and streamline the process. From the selected movie’s page you can view trailers, ratings, and more.\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t\t<div className='sketches'>\n\t\t\t\t<img className='sketch' src={require('../../images/riverSketch1.png')} alt=\"sketch\"/>\n\t\t\t\t<img className='sketch' src={require('../../images/riverSketch2.png')} alt=\"sketch\"/>\n\t\t\t\t<img className='sketch' src={require('../../images/riverSketch3.png')} alt=\"sketch\"/>\n\t\t\t</div>\n\t\t\t<div className= \"section\"> \n\t\t\t\t<h3>Under The Hood</h3>\n\t\t\t\t<p>\n\t\t\t\t\tFor this single page web application (SPA) I utilized Ruby on Rails to build out a database that consists of the streaming service providers, a model for the users and streams, and a web scraper built on Nokogiri to gather the lists of movies from the internet. \n\n\t\t\t\t\tTo form the frontend side of River I used ReactJS + Redux and Thunk. In addition to these I used Auth0 to handle secure logins via email and Facebook. \n\t\t\t\t\t<br/>\n\t\t\t\t\t<br/>\n\t\t\t\t\tOn the route to collect the necessary info for the movie titles I scraped on the backend, I had to chain multiple fetch requests to collect targeted data from omdbapi.com (an imdb api source) and send that data to YouTube’s api to gather the movie trailer before patching the collected data back to my backend api.\n\t\t\t\t</p>\n\t\t\t</div>\n\t\t</div>\n\t)\n}\nexport default MoreInfo"]},"metadata":{},"sourceType":"module"}
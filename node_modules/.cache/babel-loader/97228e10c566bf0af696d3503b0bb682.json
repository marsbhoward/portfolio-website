{"ast":null,"code":"import React from 'react'; // vector add\n\nfunction addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n} // vector substract\n\n\nfunction subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n}\n/**\r\n * Calculates velocity\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @param len the length of the delta vector\r\n * @returns velocity\r\n */\n\n\nfunction calculateVelocity(delta, delta_t, len) {\n  len = len || Math.hypot.apply(Math, delta);\n  return delta_t ? len / delta_t : 0;\n}\n/**\r\n * Calculates velocities vector\r\n * @template T the expected vector type\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time offset\r\n * @returns velocities vector\r\n */\n\n\nfunction calculateVelocities(delta, delta_t) {\n  return delta_t ? delta.map(function (v) {\n    return v / delta_t;\n  }) : Array(delta.length).fill(0);\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\n/**\r\n * Calculates direction\r\n * @template T the expected vector type\r\n * @param delta\r\n * @param len\r\n * @returns direction\r\n */\n\n\nfunction calculateDirection(delta, len) {\n  len = len || Math.hypot.apply(Math, delta) || 1;\n  return delta.map(function (v) {\n    return v / len;\n  });\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\n\nfunction calculateAllKinematics(movement, delta, delta_t) {\n  var len = Math.hypot.apply(Math, delta);\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len)\n  };\n}\n\nfunction getIntentionalDisplacement(movement, threshold) {\n  var abs = Math.abs(movement);\n  return abs >= threshold ? Math.sign(movement) * threshold : false;\n}\n\nfunction minMax(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\n\n\nfunction rubberband2(distance, constant) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5);\n}\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n  if (constant === void 0) {\n    constant = 0.15;\n  }\n\n  if (constant === 0) return minMax(position, min, max);\n\n  if (position < min) {\n    return -rubberband(min - position, max - min, constant) + min;\n  }\n\n  if (position > max) {\n    return rubberband(position - max, max - min, constant) + max;\n  }\n\n  return position;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o) {\n  var i = 0;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  i = o[Symbol.iterator]();\n  return i.next.bind(i);\n} // blank function\n\n\nfunction noop() {} // returns a function that chains all functions given as parameters\n\n\nvar chainFns = function chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return fns.forEach(function (fn) {\n      return fn.apply(void 0, args);\n    });\n  };\n};\n\nvar def = {\n  array: function array(value) {\n    return Array.isArray(value) ? value : [value, value];\n  },\n  withDefault: function withDefault(value, defaultIfUndefined) {\n    return value !== void 0 ? value : defaultIfUndefined;\n  }\n};\n\nfunction matchKeysFromObject(obj, matchingObject) {\n  var o = {};\n  Object.entries(obj).forEach(function (_ref) {\n    var key = _ref[0],\n        value = _ref[1];\n    return (value !== void 0 || key in matchingObject) && (o[key] = value);\n  });\n  return o;\n}\n\nfunction valueFn(v) {\n  return typeof v === 'function' ? v() : v;\n}\n\nfunction getInitialState() {\n  // common initial state for all gestures\n  var initialCommon = {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined\n  }; // initial state for coordinates-based gestures\n\n  var initialCoordinates = {\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  }; // initial state for distance and angle-based gestures (pinch)\n\n  var initialDistanceAngle = {\n    da: [0, 0],\n    vdva: [0, 0],\n    origin: undefined,\n    turns: 0\n  }; // initial state object (used by the gesture controller)\n\n  return {\n    shared: {\n      hovering: false,\n      scrolling: false,\n      wheeling: false,\n      dragging: false,\n      moving: false,\n      pinching: false,\n      touches: 0,\n      buttons: 0,\n      down: false,\n      shiftKey: false,\n      altKey: false,\n      metaKey: false,\n      ctrlKey: false\n    },\n    drag: _extends({}, initialCommon, {}, initialCoordinates, {\n      _isTap: true,\n      _delayedEvent: false,\n      tap: false,\n      swipe: [0, 0]\n    }),\n    pinch: _extends({}, initialCommon, {}, initialDistanceAngle),\n    wheel: _extends({}, initialCommon, {}, initialCoordinates),\n    move: _extends({}, initialCommon, {}, initialCoordinates),\n    scroll: _extends({}, initialCommon, {}, initialCoordinates)\n  };\n}\n\nvar setListeners = function setListeners(add) {\n  return function (el, listeners, options) {\n    var action = add ? 'addEventListener' : 'removeEventListener';\n    listeners.forEach(function (_ref) {\n      var eventName = _ref[0],\n          fn = _ref[1];\n      return el[action](eventName, fn, options);\n    });\n  };\n};\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\n\nfunction supportsGestureEvents() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar addListeners = /*#__PURE__*/setListeners(true);\nvar removeListeners = /*#__PURE__*/setListeners(false);\n/**\r\n * Gets modifier keys from event\r\n * @param event\r\n * @returns modifier keys\r\n */\n\nfunction getModifierKeys(event) {\n  var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey;\n  return {\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n\nfunction getTouchEvents(event) {\n  if ('touches' in event) {\n    var touches = event.touches,\n        changedTouches = event.changedTouches;\n    return touches.length > 0 ? touches : changedTouches;\n  }\n\n  return null;\n}\n\nfunction getGenericEventData(event) {\n  var buttons = 'buttons' in event ? event.buttons : 0;\n  var touchEvents = getTouchEvents(event);\n  var touches = touchEvents && touchEvents.length || 0;\n  var down = touches > 0 || buttons > 0;\n  return _extends({\n    touches: touches,\n    down: down,\n    buttons: buttons\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */\n\n\nfunction getScrollEventValues(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n      scrollX = _event$currentTarget.scrollX,\n      scrollY = _event$currentTarget.scrollY,\n      scrollLeft = _event$currentTarget.scrollLeft,\n      scrollTop = _event$currentTarget.scrollTop;\n  return {\n    values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]\n  };\n}\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */\n\n\nfunction getWheelEventValues(event) {\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return {\n    values: [deltaX, deltaY]\n  };\n}\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */\n\n\nfunction getPointerEventValues(event) {\n  var touchEvents = getTouchEvents(event);\n\n  var _ref2 = touchEvents ? touchEvents[0] : event,\n      clientX = _ref2.clientX,\n      clientY = _ref2.clientY;\n\n  return {\n    values: [clientX, clientY]\n  };\n}\n\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */\n\nfunction getWebkitGestureEventValues(event) {\n  return {\n    values: [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation]\n  };\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\n\nfunction getTwoTouchesEventData(event) {\n  var touches = event.touches;\n  var dx = touches[1].clientX - touches[0].clientX;\n  var dy = touches[1].clientY - touches[0].clientY;\n  var values = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];\n  var origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];\n  return {\n    values: values,\n    origin: origin\n  };\n}\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n *\r\n * @template BinderType the type the bind function should return\r\n */\n\n\nvar Controller = function Controller() {\n  var _this = this;\n\n  this.state = getInitialState(); // state for all gestures\n\n  this.timeouts = {}; // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n\n  this.domListeners = []; // when config.domTarget is set, we attach events directly to the dom\n\n  this.windowListeners = {}; // keeps track of window listeners added by gestures (drag only at the moment)\n\n  this.bindings = {}; // an object holding the handlers associated to the gestures\n\n  /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */\n\n  this.clean = function () {\n    _this.resetBindings();\n\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    Object.keys(_this.windowListeners).forEach(function (stateKey) {\n      return _this.removeWindowListeners(stateKey);\n    });\n  };\n  /**\r\n   * Function run every time the bind function is run (ie on every render).\r\n   * Resets the binding object and remove dom listeners attached to config.domTarget\r\n   */\n\n\n  this.resetBindings = function () {\n    _this.bindings = {};\n\n    var domTarget = _this.getDomTarget();\n\n    if (domTarget) {\n      removeListeners(domTarget, _this.domListeners, _this.config.eventOptions);\n      _this.domListeners = [];\n    }\n  };\n  /**\r\n   * Returns the domTarget element and parses a ref if needed.\r\n   */\n\n\n  this.getDomTarget = function () {\n    var domTarget = _this.config.domTarget;\n    return domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n  };\n  /**\r\n   * Commodity function to let recognizers simply add listeners to config.window.\r\n   */\n\n\n  this.addWindowListeners = function (stateKey, listeners) {\n    if (!_this.config.window) return; // we use this.windowListeners to keep track of the listeners we add\n\n    _this.windowListeners[stateKey] = listeners;\n    addListeners(_this.config.window, listeners, _this.config.eventOptions);\n  };\n  /**\r\n   * Commodity function to let recognizers simply remove listeners to config.window.\r\n   */\n\n\n  this.removeWindowListeners = function (stateKey) {\n    if (!_this.config.window) return;\n    var listeners = _this.windowListeners[stateKey];\n\n    if (listeners) {\n      removeListeners(_this.config.window, listeners, _this.config.eventOptions);\n      delete _this.windowListeners[stateKey];\n    }\n  };\n  /**\r\n   * When config.domTarget is set, this function will add dom listeners to it\r\n   */\n\n\n  this.addDomTargetListeners = function (target) {\n    /** We iterate on the entries of this.binding for each event, then we chain\r\n     * the array of functions mapped to it and push them to this.domListeners\r\n     */\n    Object.entries(_this.bindings).forEach(function (_ref) {\n      var event = _ref[0],\n          fns = _ref[1];\n\n      _this.domListeners.push([event.substr(2).toLowerCase(), chainFns.apply(void 0, fns)]);\n    });\n    addListeners(target, _this.domListeners, _this.config.eventOptions);\n  };\n  /**\r\n   * this.bindings is an object which keys match ReactEventHandlerKeys.\r\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n   * that key.\r\n   */\n\n\n  this.addBindings = function (eventNames, fn) {\n    var eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;\n    eventNamesArray.forEach(function (eventName) {\n      if (_this.bindings[eventName]) _this.bindings[eventName].push(fn);else _this.bindings[eventName] = [fn];\n    });\n  };\n  /**\r\n   * getBindings will return an object that will be bound by users\r\n   * to the react component they want to interact with.\r\n   */\n\n\n  this.getBindings = function () {\n    var bindings = {};\n    var captureString = _this.config.captureString;\n    Object.entries(_this.bindings).forEach(function (_ref2) {\n      var event = _ref2[0],\n          fns = _ref2[1];\n      var fnsArray = Array.isArray(fns) ? fns : [fns];\n      var key = event + captureString;\n      bindings[key] = chainFns.apply(void 0, fnsArray);\n    });\n    return bindings;\n  };\n\n  this.getBind = function () {\n    // If config.domTarget is set we add event listeners to it and return the clean function.\n    if (_this.config.domTarget) {\n      var domTarget = _this.getDomTarget();\n\n      domTarget && _this.addDomTargetListeners(domTarget);\n      return _this.clean;\n    } // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n\n\n    return _this.getBindings();\n  };\n};\n/**\r\n * @private\r\n *\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param {Partial<InternalHandlers>} handlers\r\n * @param {RecognizerClasses} classes\r\n * @param {InternalConfig} config\r\n * @param {NativeHandlersPartial} nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useRecognizers(handlers, classes, config, nativeHandlers) {\n  // The gesture controller keeping track of all gesture states\n  var controller = React.useMemo(function () {\n    var current = new Controller();\n    /**\r\n     * The bind function will create gesture recognizers and return the right\r\n     * bind object depending on whether `domTarget` was specified in the config object.\r\n     */\n\n    var bind = function bind() {\n      current.resetBindings();\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      for (var _iterator = _createForOfIteratorHelperLoose(classes), _step; !(_step = _iterator()).done;) {\n        var RecognizerClass = _step.value;\n        new RecognizerClass(current, args).addBindings();\n      } // we also add event bindings for native handlers\n\n\n      if (controller.nativeRefs) {\n        for (var eventName in controller.nativeRefs) {\n          current.addBindings(eventName, // @ts-ignore we're cheating when it comes to event type :(\n          controller.nativeRefs[eventName]);\n        }\n      }\n\n      return current.getBind();\n    };\n\n    return {\n      nativeRefs: nativeHandlers,\n      current: current,\n      bind: bind\n    };\n  }, []); // We reassign the config and handlers to the controller on every render.\n\n  controller.current.config = config;\n  controller.current.handlers = handlers; // We assign nativeHandlers, otherwise they won't be refreshed on the next render.\n\n  controller.nativeRefs = nativeHandlers; // Run controller clean functions on unmount.\n\n  React.useEffect(function () {\n    return controller.current.clean;\n  }, []);\n  return controller.bind;\n}\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n *\r\n * @protected\r\n * @abstract\r\n * @type {StateKey<T>} whether the Recognizer should deal with coordinates or distance / angle\r\n */\n\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(stateKey, controller, args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    this.stateKey = stateKey;\n    this.controller = controller;\n    this.args = args;\n    this.debounced = true; // Convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n\n      if (ms === void 0) {\n        ms = 140;\n      }\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // Convenience method to clear a timeout for a given gesture\n\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    }; // Convenience method to add window listeners for a given gesture\n\n\n    this.addWindowListeners = function (listeners) {\n      _this.controller.addWindowListeners(_this.stateKey, listeners);\n    }; // Convenience method to remove window listeners for a given gesture\n\n\n    this.removeWindowListeners = function () {\n      _this.controller.removeWindowListeners(_this.stateKey);\n    };\n    /**\r\n     * Returns the reinitialized start state for the gesture.\r\n     * Should be common to all gestures.\r\n     *\r\n     * @param {Vector2} values\r\n     * @param {UseGestureEvent} event\r\n     * @returns - the start state for the gesture\r\n     */\n\n\n    this.getStartGestureState = function (values, event) {\n      return _extends({}, getInitialState()[_this.stateKey], {\n        _active: true,\n        values: values,\n        initial: values,\n        offset: _this.state.offset,\n        lastOffset: _this.state.offset,\n        startTime: event.timeStamp\n      });\n    }; // Runs rubberband on a vector\n\n\n    this.rubberband = function (vector, rubberband) {\n      var bounds = _this.config.bounds;\n      /**\r\n       * [x, y]: [rubberband(x, min, max), rubberband(y, min, max)]\r\n       */\n\n      return vector.map(function (v, i) {\n        return rubberbandIfOutOfBounds(v, bounds[i][0], bounds[i][1], rubberband[i]);\n      });\n    };\n    /**\r\n     * Fires the gesture handler\r\n     *\r\n     * @param {boolean} [forceFlag] - if true, then the handler will fire even if the gesture is not intentional\r\n     */\n\n\n    this.fireGestureHandler = function (forceFlag) {\n      /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */\n      if (_this.state._blocked) {\n        // we need debounced gestures to end by themselves\n        if (!_this.debounced) {\n          _this.state._active = false;\n\n          _this.clean();\n        }\n\n        return null;\n      } // If the gesture has no intentional dimension, don't do fire the handler.\n\n\n      var _this$state$_intentio = _this.state._intentional,\n          intentionalX = _this$state$_intentio[0],\n          intentionalY = _this$state$_intentio[1];\n      if (!forceFlag && intentionalX === false && intentionalY === false) return null;\n      var _this$state = _this.state,\n          _active = _this$state._active,\n          active = _this$state.active;\n      _this.state.active = _active;\n      _this.state.first = _active && !active; // `first` is true when the gesture becomes active\n\n      _this.state.last = active && !_active; // `last` is true when the gesture becomes inactive\n\n      _this.controller.state.shared[_this.ingKey] = _active; // Sets dragging, pinching, etc. to the gesture active state\n\n      var state = _extends({}, _this.controller.state.shared, {}, _this.state, {}, _this.mapStateValues(_this.state)); // @ts-ignore\n\n\n      var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n\n\n      _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo; // Cleans the gesture when the gesture is no longer active.\n\n      if (!_active) _this.clean();\n      return state;\n    };\n  } // Returns the gesture config\n\n\n  var _proto = Recognizer.prototype; // Conveninence method to update the shared state\n\n  _proto.updateSharedState = function updateSharedState(sharedState) {\n    Object.assign(this.controller.state.shared, sharedState);\n  } // Conveninence method to update the gesture state\n  ;\n\n  _proto.updateGestureState = function updateGestureState(gestureState) {\n    Object.assign(this.state, gestureState);\n  }\n  /**\r\n   * Returns a generic, common payload for all gestures from an event.\r\n   *\r\n   * @param {UseGestureEvent} event\r\n   * @param {boolean} [isStartEvent]\r\n   * @returns - the generic gesture payload\r\n   */\n  ;\n\n  _proto.getGenericPayload = function getGenericPayload(event, isStartEvent) {\n    var timeStamp = event.timeStamp,\n        type = event.type;\n    var _this$state2 = this.state,\n        values = _this$state2.values,\n        startTime = _this$state2.startTime;\n    return {\n      _lastEventType: type,\n      event: event,\n      timeStamp: timeStamp,\n      elapsedTime: isStartEvent ? 0 : timeStamp - startTime,\n      args: this.args,\n      previous: values\n    };\n  }\n  /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement, _state) {\n    return {\n      _intentional: _intentional,\n      _blocked: false\n    };\n  }\n  /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */\n  ;\n\n  _proto.getMovement = function getMovement(values, state) {\n    if (state === void 0) {\n      state = this.state;\n    }\n\n    var _this$config = this.config,\n        initial = _this$config.initial,\n        threshold = _this$config.threshold,\n        rubberband = _this$config.rubberband;\n    var t0 = threshold[0],\n        t1 = threshold[1];\n    var _state2 = state,\n        _initial = _state2._initial,\n        _active = _state2._active,\n        intentional = _state2._intentional,\n        lastOffset = _state2.lastOffset,\n        prevMovement = _state2.movement;\n    var i0 = intentional[0],\n        i1 = intentional[1];\n\n    var _this$getInternalMove = this.getInternalMovement(values, state),\n        _m0 = _this$getInternalMove[0],\n        _m1 = _this$getInternalMove[1];\n    /**\r\n     * For both dimensions of the gesture, check its intentionality on each frame.\r\n     */\n\n\n    if (i0 === false) {\n      i0 = getIntentionalDisplacement(_m0, t0);\n    }\n\n    if (i1 === false) {\n      i1 = getIntentionalDisplacement(_m1, t1);\n    } // Get gesture specific state properties based on intentionality and movement.\n\n\n    var intentionalityCheck = this.checkIntentionality([i0, i1], [_m0, _m1], state);\n    var _intentional = intentionalityCheck._intentional,\n        _blocked = intentionalityCheck._blocked;\n    var _i0 = _intentional[0],\n        _i1 = _intentional[1];\n    var _movement = [_m0, _m1];\n    if (_i0 !== false && intentional[0] === false) _initial[0] = valueFn(initial)[0];\n    if (_i1 !== false && intentional[1] === false) _initial[1] = valueFn(initial)[1];\n    /**\r\n     * If the gesture has been blocked (from gesture specific checkIntentionality),\r\n     * stop right there.\r\n     */\n\n    if (_blocked) return _extends({}, intentionalityCheck, {\n      _movement: _movement,\n      delta: [0, 0]\n    });\n    /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */\n\n    var movement = [_i0 !== false ? _m0 - _i0 : valueFn(initial)[0], _i1 !== false ? _m1 - _i1 : valueFn(initial)[1]];\n    var offset = addV(movement, lastOffset);\n    /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */\n\n    var _rubberband = _active ? rubberband : [0, 0];\n\n    movement = this.rubberband(addV(movement, _initial), _rubberband); // rubberbanded movement\n\n    return _extends({}, intentionalityCheck, {\n      _initial: _initial,\n      _movement: _movement,\n      movement: movement,\n      offset: this.rubberband(offset, _rubberband),\n      delta: subV(movement, prevMovement)\n    });\n  } // Cleans the gesture. Can be overriden by gestures.\n  ;\n\n  _proto.clean = function clean() {\n    this.clearTimeout();\n    this.removeWindowListeners();\n  };\n\n  _createClass(Recognizer, [{\n    key: \"config\",\n    get: function get() {\n      return this.controller.config[this.stateKey];\n    } // Is the gesture enabled\n\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.config.enabled;\n    } // Returns the controller state for a given gesture\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    } // Returns the gesture handler\n\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.controller.handlers[this.stateKey];\n    }\n  }]);\n\n  return Recognizer;\n}();\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n * @abstract\r\n * @class CoordinatesRecognizer\r\n * @extends {Recognizer<T>}\r\n * @template T\r\n */\n\n\nvar CoordinatesRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = CoordinatesRecognizer.prototype;\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    return subV(values, state.initial);\n  }\n  /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   *\r\n   * @param {[FalseOrNumber, FalseOrNumber]} _intentional\r\n   * @param {Vector2} _movement\r\n   * @param {PartialGestureState<T>} state\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement, state) {\n    var _intentional2 = _intentional,\n        _ix = _intentional2[0],\n        _iy = _intentional2[1];\n    var intentionalMovement = _ix !== false || _iy !== false;\n    var axis = state.axis;\n    var _blocked = false; // If the movement is intentional, we can compute axis.\n\n    if (intentionalMovement) {\n      var _movement$map = _movement.map(Math.abs),\n          absX = _movement$map[0],\n          absY = _movement$map[1];\n\n      var _this$config = this.config,\n          configAxis = _this$config.axis,\n          lockDirection = _this$config.lockDirection; // We make sure we only set axis value if it hadn't been detected before.\n\n      axis = axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined);\n\n      if (!!configAxis || lockDirection) {\n        if (!!axis) {\n          // If the detected axis doesn't match the config axis we block the gesture\n          if (!!configAxis && axis !== configAxis) _blocked = true;else {\n            // Otherwise we prevent the gesture from updating the unwanted axis.\n            var lockedIndex = axis === 'x' ? 1 : 0;\n            _intentional[lockedIndex] = false;\n          }\n        } else {\n          // Until we've detected the axis, we prevent the hnadler from updating.\n          _intentional = [false, false];\n        }\n      }\n    }\n\n    return {\n      _intentional: _intentional,\n      _blocked: _blocked,\n      axis: axis\n    };\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var timeStamp = this.state.timeStamp;\n    var movementDetection = this.getMovement(values, this.state);\n    var _blocked = movementDetection._blocked,\n        delta = movementDetection.delta,\n        movement = movementDetection.movement;\n    if (_blocked) return movementDetection;\n    var delta_t = event.timeStamp - timeStamp;\n    var kinematics = calculateAllKinematics(movement, delta, delta_t);\n    return _extends({\n      values: values,\n      delta: delta\n    }, movementDetection, {}, kinematics);\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      xy: state.values,\n      vxvy: state.velocities\n    };\n  };\n\n  return CoordinatesRecognizer;\n}(Recognizer);\n\nvar TAP_DISTANCE_THRESHOLD = 3;\nvar SWIPE_MAX_ELAPSED_TIME = 220;\nvar FILTER_REPEATED_EVENTS_DELAY = 200;\n\nvar DragRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n\n  function DragRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'drag', controller, args) || this;\n    _this.ingKey = 'dragging';\n    _this.wasTouch = false;\n\n    _this.isEventTypeTouch = function (type) {\n      return !!type && type.indexOf('touch') === 0;\n    };\n\n    _this.dragShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n          touches = _getGenericEventData.touches;\n\n      var _lastEventType = _this.state._lastEventType;\n      /**\r\n       * This tries to filter out mouse events triggered by touch screens\r\n       * */\n      // If the previous gesture was touch-based, and the current one is mouse based,\n      // this means that we might be dealing with mouse simulated events if they're close to\n      // each other. We're only doing this check when we're not using pointer events.\n\n      if (!_this.controller.config.pointer && _this.isEventTypeTouch(_lastEventType) && !_this.isEventTypeTouch(event.type)) {\n        var delay = Math.abs(event.timeStamp - _this.state.startTime);\n        if (delay < FILTER_REPEATED_EVENTS_DELAY) return false;\n      }\n\n      return _this.enabled && touches < 2;\n    };\n\n    _this.setPointers = function (event) {\n      var currentTarget = event.currentTarget,\n          pointerId = event.pointerId;\n      if (currentTarget) currentTarget.setPointerCapture(pointerId);\n\n      _this.updateGestureState({\n        currentTarget: currentTarget,\n        pointerId: pointerId\n      });\n    };\n\n    _this.removePointers = function () {\n      var _this$state = _this.state,\n          currentTarget = _this$state.currentTarget,\n          pointerId = _this$state.pointerId;\n      if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId);\n    };\n\n    _this.setListeners = function (isTouch) {\n      _this.removeWindowListeners();\n\n      var dragListeners = isTouch ? [['touchmove', _this.onDragChange], ['touchend', _this.onDragEnd], ['touchcancel', _this.onDragEnd]] : [['mousemove', _this.onDragChange], ['mouseup', _this.onDragEnd]];\n\n      _this.addWindowListeners(dragListeners);\n    };\n\n    _this.onDragStart = function (event) {\n      if (!_this.dragShouldStart(event)) return; // if pointers events\n\n      if (_this.controller.config.pointer) _this.setPointers(event);else _this.setListeners(_this.isEventTypeTouch(event.type));\n\n      if (_this.config.delay > 0) {\n        _this.state._delayedEvent = true;\n        if (typeof event.persist === 'function') event.persist();\n\n        _this.setTimeout(function () {\n          return _this.startDrag(event);\n        }, _this.config.delay);\n      } else {\n        _this.startDrag(event);\n      }\n    };\n\n    _this.onDragChange = function (event) {\n      var canceled = _this.state.canceled;\n      if (canceled) return;\n\n      if (!_this.state._active) {\n        if (_this.state._delayedEvent) {\n          _this.clearTimeout();\n\n          _this.startDrag(event);\n        }\n\n        return;\n      }\n\n      var genericEventData = getGenericEventData(event);\n\n      if (!genericEventData.down) {\n        _this.onDragEnd(event);\n\n        return;\n      }\n\n      _this.updateSharedState(genericEventData);\n\n      var _getPointerEventValue = getPointerEventValues(event),\n          values = _getPointerEventValue.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      var _isTap = _this.state._isTap;\n      if (_isTap && calculateDistance(kinematics._movement) >= TAP_DISTANCE_THRESHOLD) _isTap = false;\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics, {\n        _isTap: _isTap,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onDragEnd = function (event) {\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n\n      var _this$state2 = _this.state,\n          _isTap = _this$state2._isTap,\n          values = _this$state2.values,\n          _this$state2$velociti = _this$state2.velocities,\n          vx = _this$state2$velociti[0],\n          vy = _this$state2$velociti[1],\n          _this$state2$movement = _this$state2.movement,\n          mx = _this$state2$movement[0],\n          my = _this$state2$movement[1],\n          _this$state2$_intenti = _this$state2._intentional,\n          ix = _this$state2$_intenti[0],\n          iy = _this$state2$_intenti[1];\n\n      var endState = _extends({}, _this.getGenericPayload(event), {}, _this.getMovement(values));\n\n      var elapsedTime = endState.elapsedTime;\n      var _this$config = _this.config,\n          _this$config$swipeVel = _this$config.swipeVelocity,\n          svx = _this$config$swipeVel[0],\n          svy = _this$config$swipeVel[1],\n          _this$config$swipeDis = _this$config.swipeDistance,\n          sx = _this$config$swipeDis[0],\n          sy = _this$config$swipeDis[1];\n      var swipe = [0, 0];\n\n      if (elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n        if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = Math.sign(vx);\n        if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = Math.sign(vy);\n      }\n\n      _this.updateGestureState(_extends({\n        event: event\n      }, endState, {\n        tap: _isTap,\n        swipe: swipe\n      }));\n\n      _this.fireGestureHandler(_this.config.filterTaps && _this.state._isTap);\n    };\n\n    _this.clean = function () {\n      _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n\n      _this.state._delayedEvent = false;\n      if (_this.controller.config.pointer) _this.removePointers();\n    };\n\n    _this.onCancel = function () {\n      _this.updateGestureState({\n        canceled: true,\n        cancel: noop\n      });\n\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = DragRecognizer.prototype;\n\n  _proto.startDrag = function startDrag(event) {\n    var _this2 = this;\n\n    var _getPointerEventValue2 = getPointerEventValues(event),\n        values = _getPointerEventValue2.values;\n\n    this.updateSharedState(getGenericEventData(event));\n\n    var startState = _extends({}, this.getStartGestureState(values, event), {}, this.getGenericPayload(event, true));\n\n    this.updateGestureState(_extends({}, startState, {}, this.getMovement(values, startState), {\n      cancel: function cancel() {\n        return _this2.onCancel();\n      }\n    }));\n    this.fireGestureHandler();\n  };\n\n  _proto.addBindings = function addBindings() {\n    if (this.controller.config.pointer) {\n      this.controller.addBindings('onPointerDown', this.onDragStart);\n      this.controller.addBindings('onPointerMove', this.onDragChange);\n      this.controller.addBindings(['onPointerUp', 'onPointerCancel'], this.onDragEnd);\n    } else {\n      this.controller.addBindings(['onTouchStart', 'onMouseDown'], this.onDragStart);\n    }\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 60;\nvar defaultWindow = typeof window !== 'undefined' ? window : undefined;\nvar defaultCoordinatesOptions = {\n  lockDirection: false,\n  axis: undefined,\n  bounds: undefined\n};\n/**\r\n * @private\r\n *\r\n * Returns the internal generic option object.\r\n *\r\n * @param {Partial<GenericOptions>} [config={}]\r\n * @returns {InternalGenericOptions}\r\n */\n\nfunction getInternalGenericOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      _config$eventOptions = _config.eventOptions;\n  _config$eventOptions = _config$eventOptions === void 0 ? {} : _config$eventOptions;\n\n  var _config$eventOptions$ = _config$eventOptions.passive,\n      passive = _config$eventOptions$ === void 0 ? true : _config$eventOptions$,\n      _config$eventOptions$2 = _config$eventOptions.capture,\n      capture = _config$eventOptions$2 === void 0 ? false : _config$eventOptions$2,\n      _config$eventOptions$3 = _config$eventOptions.pointer,\n      pointer = _config$eventOptions$3 === void 0 ? false : _config$eventOptions$3,\n      _config$window = _config.window,\n      window = _config$window === void 0 ? defaultWindow : _config$window,\n      _config$domTarget = _config.domTarget,\n      domTarget = _config$domTarget === void 0 ? undefined : _config$domTarget,\n      _config$enabled = _config.enabled,\n      enabled = _config$enabled === void 0 ? true : _config$enabled,\n      restConfig = _objectWithoutPropertiesLoose(_config, [\"eventOptions\", \"window\", \"domTarget\", \"enabled\"]);\n\n  return _extends({}, restConfig, {\n    enabled: enabled,\n    domTarget: domTarget,\n    window: window,\n    // passive is always true if there's no domTarget\n    eventOptions: {\n      passive: !domTarget || !!passive,\n      capture: !!capture\n    },\n    captureString: capture ? 'Capture' : '',\n    pointer: !!pointer\n  });\n}\n\nfunction getInternalGestureOptions(gestureConfig) {\n  var _gestureConfig$thresh = gestureConfig.threshold,\n      threshold = _gestureConfig$thresh === void 0 ? undefined : _gestureConfig$thresh,\n      _gestureConfig$rubber = gestureConfig.rubberband,\n      rubberband = _gestureConfig$rubber === void 0 ? 0 : _gestureConfig$rubber,\n      _gestureConfig$enable = gestureConfig.enabled,\n      enabled = _gestureConfig$enable === void 0 ? true : _gestureConfig$enable,\n      _gestureConfig$initia = gestureConfig.initial,\n      initial = _gestureConfig$initia === void 0 ? [0, 0] : _gestureConfig$initia;\n  if (typeof rubberband === 'boolean') rubberband = rubberband ? DEFAULT_RUBBERBAND : 0;\n  if (threshold === void 0) threshold = 0;\n  return {\n    enabled: enabled,\n    initial: initial,\n    threshold: def.array(threshold),\n    rubberband: def.array(rubberband)\n  };\n}\n\nfunction getInternalCoordinatesOptions(coordinatesConfig) {\n  if (coordinatesConfig === void 0) {\n    coordinatesConfig = {};\n  }\n\n  var _coordinatesConfig = coordinatesConfig,\n      axis = _coordinatesConfig.axis,\n      lockDirection = _coordinatesConfig.lockDirection,\n      _coordinatesConfig$bo = _coordinatesConfig.bounds,\n      bounds = _coordinatesConfig$bo === void 0 ? {} : _coordinatesConfig$bo,\n      internalOptions = _objectWithoutPropertiesLoose(_coordinatesConfig, [\"axis\", \"lockDirection\", \"bounds\"]);\n\n  var boundsArray = [[def.withDefault(bounds.left, -Infinity), def.withDefault(bounds.right, Infinity)], [def.withDefault(bounds.top, -Infinity), def.withDefault(bounds.bottom, Infinity)]];\n  return _extends({}, getInternalGestureOptions(internalOptions), {}, defaultCoordinatesOptions, {}, matchKeysFromObject({\n    axis: axis,\n    lockDirection: lockDirection\n  }, coordinatesConfig), {\n    bounds: boundsArray\n  });\n}\n\nfunction getInternalDistanceAngleOptions(distanceAngleConfig) {\n  if (distanceAngleConfig === void 0) {\n    distanceAngleConfig = {};\n  }\n\n  var _distanceAngleConfig = distanceAngleConfig,\n      _distanceAngleConfig$ = _distanceAngleConfig.distanceBounds,\n      distanceBounds = _distanceAngleConfig$ === void 0 ? {} : _distanceAngleConfig$,\n      _distanceAngleConfig$2 = _distanceAngleConfig.angleBounds,\n      angleBounds = _distanceAngleConfig$2 === void 0 ? {} : _distanceAngleConfig$2,\n      internalOptions = _objectWithoutPropertiesLoose(_distanceAngleConfig, [\"distanceBounds\", \"angleBounds\"]);\n\n  var boundsArray = [[def.withDefault(distanceBounds.min, -Infinity), def.withDefault(distanceBounds.max, Infinity)], [def.withDefault(angleBounds.min, -Infinity), def.withDefault(angleBounds.max, Infinity)]];\n  return _extends({}, getInternalGestureOptions(internalOptions), {\n    bounds: boundsArray\n  });\n}\n\nfunction getInternalDragOptions(dragConfig) {\n  if (dragConfig === void 0) {\n    dragConfig = {};\n  }\n\n  var _dragConfig = dragConfig,\n      enabled = _dragConfig.enabled,\n      threshold = _dragConfig.threshold,\n      bounds = _dragConfig.bounds,\n      rubberband = _dragConfig.rubberband,\n      initial = _dragConfig.initial,\n      dragOptions = _objectWithoutPropertiesLoose(_dragConfig, [\"enabled\", \"threshold\", \"bounds\", \"rubberband\", \"initial\"]);\n\n  var _dragOptions$swipeVel = dragOptions.swipeVelocity,\n      swipeVelocity = _dragOptions$swipeVel === void 0 ? DEFAULT_SWIPE_VELOCITY : _dragOptions$swipeVel,\n      _dragOptions$swipeDis = dragOptions.swipeDistance,\n      swipeDistance = _dragOptions$swipeDis === void 0 ? DEFAULT_SWIPE_DISTANCE : _dragOptions$swipeDis,\n      _dragOptions$delay = dragOptions.delay,\n      delay = _dragOptions$delay === void 0 ? false : _dragOptions$delay,\n      _dragOptions$filterTa = dragOptions.filterTaps,\n      filterTaps = _dragOptions$filterTa === void 0 ? false : _dragOptions$filterTa,\n      axis = dragOptions.axis,\n      lockDirection = dragOptions.lockDirection;\n\n  if (threshold === void 0) {\n    threshold = Math.max(0, filterTaps ? 3 : 0, lockDirection || axis ? 1 : 0);\n  } else {\n    filterTaps = true;\n  }\n\n  var internalCoordinatesOptions = getInternalCoordinatesOptions(matchKeysFromObject({\n    enabled: enabled,\n    threshold: threshold,\n    bounds: bounds,\n    rubberband: rubberband,\n    axis: axis,\n    lockDirection: lockDirection,\n    initial: initial\n  }, dragConfig));\n  return _extends({}, internalCoordinatesOptions, {\n    filterTaps: filterTaps || internalCoordinatesOptions.threshold[0] + internalCoordinatesOptions.threshold[1] > 0,\n    swipeVelocity: def.array(swipeVelocity),\n    swipeDistance: def.array(swipeDistance),\n    delay: typeof delay === 'number' ? delay : delay ? DEFAULT_DRAG_DELAY : 0\n  });\n}\n/**\r\n * @public\r\n *\r\n * Drag hook.\r\n *\r\n * @param {Handler<'drag'>} handler - the function fired every time the drag gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and drag options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useDrag(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      drag = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    drag: getInternalDragOptions(drag)\n  });\n\n  return useRecognizers({\n    drag: handler\n  }, [DragRecognizer], mergedConfig);\n}\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n * @abstract\r\n * @class DistanceAngleRecognizer\r\n * @extends {Recognizer<T>}\r\n * @template T\r\n */\n\n\nvar DistanceAngleRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n\n  function DistanceAngleRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = DistanceAngleRecognizer.prototype;\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n\n  _proto.getInternalMovement = function getInternalMovement(_ref, state) {\n    var d = _ref[0],\n        a = _ref[1];\n    var da = state.values,\n        turns = state.turns,\n        initial = state.initial; // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n\n    a = a !== void 0 ? a : da[1];\n    var delta_a = a - da[1];\n    /**\r\n     * The angle value might jump from 179deg to -179deg when we actually want to\r\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\r\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\r\n     */\n\n    var newTurns = Math.abs(delta_a) > 270 ? turns + Math.sign(delta_a) : turns; // we update the angle difference to its corrected value\n\n    var movement_d = d - initial[0];\n    var movement_a = a - 360 * newTurns - initial[1];\n    return [movement_d, movement_a];\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var _this$state = this.state,\n        timeStamp = _this$state.timeStamp,\n        initial = _this$state.initial;\n    var movementDetection = this.getMovement(values, this.state);\n    var delta = movementDetection.delta,\n        movement = movementDetection.movement;\n    var turns = (values[1] - movement[1] - initial[1]) / 360;\n    var delta_t = event.timeStamp - timeStamp;\n    var kinematics = calculateAllKinematics(movement, delta, delta_t);\n    return _extends({\n      values: values,\n      delta: delta,\n      turns: turns\n    }, movementDetection, {}, kinematics);\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      da: state.values,\n      vdva: state.velocities\n    };\n  };\n\n  return DistanceAngleRecognizer;\n}(Recognizer);\n\nvar PinchRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n\n  function PinchRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n    _this.ingKey = 'pinching';\n\n    _this.pinchShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n          touches = _getGenericEventData.touches;\n\n      return _this.enabled && touches === 2;\n    };\n\n    _this.onPinchStart = function (event) {\n      if (!_this.pinchShouldStart(event)) return;\n\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa.values,\n          origin = _getTwoTouchesEventDa.origin;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true));\n\n      _this.updateGestureState(_extends({}, startState, {}, _this.getMovement(values, startState), {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n          canceled = _this$state.canceled,\n          timeStamp = _this$state.timeStamp,\n          _active = _this$state._active;\n      if (canceled || !_active) return;\n      var genericEventData = getGenericEventData(event);\n      if (genericEventData.touches !== 2 || event.timeStamp === timeStamp) return;\n\n      _this.updateSharedState(genericEventData);\n\n      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa2.values,\n          origin = _getTwoTouchesEventDa2.origin;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics, {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchEnd = function (event) {\n      if (!_this.state.active) return;\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      _this.updateGestureState(_extends({\n        event: event\n      }, _this.getGenericPayload(event), {}, _this.getMovement(_this.state.values)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onCancel = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState({\n        canceled: true,\n        cancel: noop\n      });\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n    /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */\n\n\n    _this.onGestureStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault();\n\n      var _getWebkitGestureEven = getWebkitGestureEventValues(event),\n          values = _getWebkitGestureEven.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true));\n\n      _this.updateGestureState(_extends({}, startState, {}, _this.getMovement(values, startState), {\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureChange = function (event) {\n      var _this$state2 = _this.state,\n          canceled = _this$state2.canceled,\n          _active = _this$state2._active;\n      if (canceled || !_active) return;\n      event.preventDefault();\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getWebkitGestureEven2 = getWebkitGestureEventValues(event),\n          values = _getWebkitGestureEven2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics, {\n        cancel: function cancel() {\n          return _this.onCancel();\n        }\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureEnd = function (event) {\n      event.preventDefault();\n      if (!_this.state.active) return;\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      _this.updateGestureState(_extends({\n        event: event\n      }, _this.getGenericPayload(event), {}, _this.getMovement(_this.state.values)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.updateTouchData = function (event) {\n      if (!_this.enabled || event.touches.length !== 2 || !_this.state._active) return;\n\n      var _getTwoTouchesEventDa3 = getTwoTouchesEventData(event),\n          origin = _getTwoTouchesEventDa3.origin;\n\n      _this.state.origin = origin;\n    };\n    /**\r\n     * PINCH WITH WHEEL\r\n     */\n\n\n    _this.wheelShouldRun = function (event) {\n      return _this.enabled && event.ctrlKey;\n    };\n\n    _this.getWheelValuesFromEvent = function (event) {\n      var _getWheelEventValues = getWheelEventValues(event),\n          _getWheelEventValues$ = _getWheelEventValues.values,\n          delta_d = _getWheelEventValues$[1];\n\n      var _this$state$values = _this.state.values,\n          prev_d = _this$state$values[0],\n          prev_a = _this$state$values[1];\n      var d = prev_d - delta_d;\n      var a = prev_a !== void 0 ? prev_a : 0;\n      return {\n        values: [d, a],\n        origin: [event.clientX, event.clientY],\n        delta: [0, delta_d]\n      };\n    };\n\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onWheelEnd);\n\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n\n    _this.onWheelStart = function (event) {\n      var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF.values,\n          delta = _this$getWheelValuesF.delta,\n          origin = _this$getWheelValuesF.origin;\n\n      if (!_this.controller.config.eventOptions.passive) {\n        event.preventDefault();\n      } else if (process.env.NODE_ENV === 'development') {\n        console.warn('To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.');\n      }\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true), {\n        initial: _this.state.values\n      });\n\n      _this.updateGestureState(_extends({}, startState, {}, _this.getMovement(values, startState), {\n        offset: values,\n        delta: delta,\n        origin: origin\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF2.values,\n          origin = _this$getWheelValuesF2.origin,\n          delta = _this$getWheelValuesF2.delta;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics, {\n        origin: origin,\n        delta: delta\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_this.getMovement(_this.state.values));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && supportsGestureEvents()) {\n      this.controller.addBindings('onGestureStart', this.onGestureStart);\n      this.controller.addBindings('onGestureChange', this.onGestureChange);\n      this.controller.addBindings(['onGestureEnd', 'onTouchCancel'], this.onGestureEnd);\n      this.controller.addBindings(['onTouchStart', 'onTouchMove'], this.updateTouchData);\n    } else {\n      this.controller.addBindings('onTouchStart', this.onPinchStart);\n      this.controller.addBindings('onTouchMove', this.onPinchChange);\n      this.controller.addBindings(['onTouchEnd', 'onTouchCancel'], this.onPinchEnd);\n      this.controller.addBindings('onWheel', this.onWheel);\n    }\n  };\n\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n/**\r\n * @public\r\n *\r\n * Pinch hook.\r\n *\r\n * @param {Handler<'pinch'>} handler - the function fired every time the pinch gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and pinch options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction usePinch(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      pinch = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    pinch: getInternalDistanceAngleOptions(pinch)\n  });\n\n  return useRecognizers({\n    pinch: handler\n  }, [PinchRecognizer], mergedConfig);\n}\n\nvar WheelRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n\n  function WheelRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'wheel', controller, args) || this;\n    _this.ingKey = 'wheeling';\n    _this.debounced = true;\n\n    _this.wheelShouldRun = function (event) {\n      if (event.ctrlKey && 'pinch' in _this.controller.handlers) return false;\n      return _this.enabled;\n    };\n\n    _this.getValuesFromEvent = function (event) {\n      var prevValues = _this.state.values;\n\n      var _getWheelEventValues = getWheelEventValues(event),\n          values = _getWheelEventValues.values;\n\n      return {\n        values: addV(values, prevValues)\n      };\n    };\n\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onWheelEnd);\n\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n\n    _this.onWheelStart = function (event) {\n      var _this$getValuesFromEv = _this.getValuesFromEvent(event),\n          values = _this$getValuesFromEv.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true), {\n        initial: _this.state.values\n      });\n\n      var movementDetection = _this.getMovement(values, startState);\n\n      var delta = movementDetection.delta;\n\n      _this.updateGestureState(_extends({}, startState, {}, movementDetection, {\n        distance: calculateDistance(delta),\n        direction: calculateDirection(delta)\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _this$getValuesFromEv2 = _this.getValuesFromEvent(event),\n          values = _this$getValuesFromEv2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = WheelRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    this.controller.addBindings('onWheel', this.onWheel);\n  };\n\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * @public\r\n *\r\n * Wheel hook.\r\n *\r\n * @param {Handler<'wheel'>} handler - the function fired every time the wheel gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and wheel options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useWheel(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      wheel = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    wheel: getInternalCoordinatesOptions(wheel)\n  });\n\n  return useRecognizers({\n    wheel: handler\n  }, [WheelRecognizer], mergedConfig);\n}\n\nvar MoveRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n\n  function MoveRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'move', controller, args) || this;\n    _this.ingKey = 'moving';\n    _this.debounced = true;\n\n    _this.moveShouldRun = function () {\n      return _this.enabled;\n    };\n\n    _this.onMove = function (event) {\n      if (!_this.moveShouldRun()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onMoveEnd);\n\n      if (!_this.state._active) _this.onMoveStart(event);else _this.onMoveChange(event);\n    };\n\n    _this.onMoveStart = function (event) {\n      var _getPointerEventValue = getPointerEventValues(event),\n          values = _getPointerEventValue.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true));\n\n      _this.updateGestureState(_extends({}, startState, {}, _this.getMovement(values, startState)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getPointerEventValue2 = getPointerEventValues(event),\n          values = _getPointerEventValue2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPointerEnter = function (event) {\n      _this.controller.state.shared.hovering = true;\n      if (!_this.controller.config.enabled) return;\n\n      if (_this.controller.config.hover.enabled) {\n        var _getPointerEventValue3 = getPointerEventValues(event),\n            values = _getPointerEventValue3.values;\n\n        var state = _extends({}, _this.controller.state.shared, {}, _this.state, {}, _this.getGenericPayload(event, true), {\n          values: values,\n          active: true,\n          hovering: true\n        });\n\n        _this.controller.handlers.hover(_extends({}, state, {}, _this.mapStateValues(state)));\n      }\n\n      if ('move' in _this.controller.handlers) _this.onMoveStart(event);\n    };\n\n    _this.onPointerLeave = function (event) {\n      _this.controller.state.shared.hovering = false;\n      if ('move' in _this.controller.handlers) _this.onMoveEnd();\n\n      if (_this.controller.config.hover.enabled) {\n        var _getPointerEventValue4 = getPointerEventValues(event),\n            values = _getPointerEventValue4.values;\n\n        var state = _extends({}, _this.controller.state.shared, {}, _this.state, {}, _this.getGenericPayload(event), {\n          values: values,\n          active: false\n        });\n\n        _this.controller.handlers.hover(_extends({}, state, {}, _this.mapStateValues(state)));\n      }\n    };\n\n    return _this;\n  }\n\n  var _proto = MoveRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    if (this.controller.config.pointer) {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onPointerMove', this.onMove);\n      }\n\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onPointerEnter', this.onPointerEnter);\n        this.controller.addBindings('onPointerLeave', this.onPointerLeave);\n      }\n    } else {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onMouseMove', this.onMove);\n      }\n\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onMouseEnter', this.onPointerEnter);\n        this.controller.addBindings('onMouseLeave', this.onPointerLeave);\n      }\n    }\n  };\n\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * @public\r\n *\r\n * Move hook.\r\n *\r\n * @param {Handler<'move'>} handler - the function fired every time the move gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and move options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useMove(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      move = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    move: getInternalCoordinatesOptions(move)\n  });\n\n  return useRecognizers({\n    move: handler\n  }, [MoveRecognizer], mergedConfig);\n}\n/**\r\n * @public\r\n *\r\n * Hover hook.\r\n *\r\n * @param {Handler<'hover'>} handler - the function fired every time the hover gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and hover options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useHover(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      hover = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    hover: _extends({\n      enabled: true\n    }, hover)\n  });\n\n  return useRecognizers({\n    hover: handler\n  }, [MoveRecognizer], mergedConfig);\n}\n\nvar ScrollRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n\n  function ScrollRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'scroll', controller, args) || this;\n    _this.ingKey = 'scrolling';\n    _this.debounced = true;\n\n    _this.scrollShouldRun = function () {\n      return _this.enabled;\n    };\n\n    _this.onScroll = function (event) {\n      if (!_this.scrollShouldRun()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onScrollEnd);\n\n      if (!_this.state._active) _this.onScrollStart(event);else _this.onScrollChange(event);\n    };\n\n    _this.onScrollStart = function (event) {\n      var _getScrollEventValues = getScrollEventValues(event),\n          values = _getScrollEventValues.values;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var startState = _extends({}, _this.getStartGestureState(values, event), {}, _this.getGenericPayload(event, true), {\n        initial: _this.state.values\n      });\n\n      var movementDetection = _this.getMovement(values, startState);\n\n      var delta = movementDetection.delta;\n\n      _this.updateGestureState(_extends({}, startState, {}, movementDetection, {\n        distance: calculateDistance(delta),\n        direction: calculateDirection(delta)\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onScrollChange = function (event) {\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getScrollEventValues2 = getScrollEventValues(event),\n          values = _getScrollEventValues2.values;\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, _this.getGenericPayload(event), {}, kinematics));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onScrollEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = ScrollRecognizer.prototype;\n\n  _proto.addBindings = function addBindings() {\n    this.controller.addBindings('onScroll', this.onScroll);\n  };\n\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * @public\r\n *\r\n * Scroll hook.\r\n *\r\n * @param {Handler<'scroll'>} handler - the function fired every time the scroll gesture updates\r\n * @param {(Config | {})} [config={}] - the config object including generic options and scroll options\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useScroll(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _config = config,\n      domTarget = _config.domTarget,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      scroll = _objectWithoutPropertiesLoose(_config, [\"domTarget\", \"eventOptions\", \"window\"]);\n  /**\r\n   * TODO: at the moment we recompute the config object at every render\r\n   * this could probably be optimized\r\n   */\n\n\n  var mergedConfig = _extends({}, getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window\n  }), {\n    scroll: getInternalCoordinatesOptions(scroll)\n  });\n\n  return useRecognizers({\n    scroll: handler\n  }, [ScrollRecognizer], mergedConfig);\n}\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {UserHandlersPartial} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useGesture(handlers, config) {\n  if (config === void 0) {\n    config = {};\n  }\n  /**\r\n   * If handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\r\n   * actions will include 'onDrag' and 'onMove.\r\n   */\n\n\n  var _React$useState = React.useState(function () {\n    return new Set(Object.keys(handlers).map(function (k) {\n      return k.replace(/End|Start/, '');\n    }));\n  }),\n      actions = _React$useState[0];\n  /**\r\n   * Here we compute the derived internal config based on the provided config object.\r\n   * We decompose the config into its generic and gesture options and compute each.\r\n   * TODO: this is currently done on every render!\r\n   */\n\n\n  var _config = config,\n      drag = _config.drag,\n      wheel = _config.wheel,\n      move = _config.move,\n      scroll = _config.scroll,\n      pinch = _config.pinch,\n      hover = _config.hover,\n      restConfig = _objectWithoutPropertiesLoose(_config, [\"drag\", \"wheel\", \"move\", \"scroll\", \"pinch\", \"hover\"]);\n\n  var mergedConfig = getInternalGenericOptions(restConfig);\n  var classes = [];\n  var internalHandlers = {}; // will hold reference to native handlers such as onClick, onMouseDown, etc.\n\n  var _nativeHandlers = _extends({}, handlers);\n\n  if (actions.has('onDrag')) {\n    classes.push(DragRecognizer);\n    internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag', _nativeHandlers);\n    mergedConfig.drag = getInternalDragOptions(drag);\n  }\n\n  if (actions.has('onWheel')) {\n    classes.push(WheelRecognizer);\n    internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel', _nativeHandlers);\n    mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n  }\n\n  if (actions.has('onScroll')) {\n    classes.push(ScrollRecognizer);\n    internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll', _nativeHandlers);\n    mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n  }\n\n  if (actions.has('onMove')) {\n    classes.push(MoveRecognizer);\n    internalHandlers.move = includeStartEndHandlers(handlers, 'onMove', _nativeHandlers);\n    mergedConfig.move = getInternalCoordinatesOptions(move);\n  }\n\n  if (actions.has('onPinch')) {\n    classes.push(PinchRecognizer);\n    internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch', _nativeHandlers);\n    mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n  }\n\n  if (actions.has('onHover')) {\n    if (!actions.has('onMove')) classes.push(MoveRecognizer);\n    internalHandlers.hover = handlers.onHover;\n    mergedConfig.hover = _extends({\n      enabled: true\n    }, hover);\n    delete _nativeHandlers.onHover;\n  }\n\n  return useRecognizers(internalHandlers, classes, mergedConfig, _nativeHandlers);\n}\n/**\r\n * @private\r\n *\r\n * This utility function will integrate start and end handlers into the regular\r\n * handler function by using first and last conditions.\r\n *\r\n * @param {UserHandlersPartial} handlers - the handlers function object\r\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\r\n * @returns\r\n */\n\n\nfunction includeStartEndHandlers(handlers, handlerKey, _nativeHandlers) {\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n  delete _nativeHandlers[handlerKey];\n  delete _nativeHandlers[startKey];\n  delete _nativeHandlers[endKey];\n\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  return fn;\n}\n\nexport { addV, rubberbandIfOutOfBounds, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","map":{"version":3,"sources":["../src/utils/math.ts","../src/utils/utils.ts","../src/utils/state.ts","../src/utils/event.ts","../src/Controller.ts","../src/hooks/useRecognizers.ts","../src/recognizers/Recognizer.ts","../src/recognizers/CoordinatesRecognizer.ts","../src/recognizers/DragRecognizer.ts","../src/utils/config.ts","../src/hooks/useDrag.ts","../src/recognizers/DistanceAngleRecognizer.ts","../src/recognizers/PinchRecognizer.ts","../src/hooks/usePinch.ts","../src/recognizers/WheelRecognizer.ts","../src/hooks/useWheel.ts","../src/recognizers/MoveRecognizer.ts","../src/hooks/useMove.ts","../src/hooks/useHover.ts","../src/recognizers/ScrollRecognizer.ts","../src/hooks/useScroll.ts","../src/hooks/useGesture.ts"],"names":["addV","v1","v2","v","subV","calculateVelocity","delta","delta_t","len","Math","calculateVelocities","Array","calculateDistance","movement","calculateDirection","calculateAllKinematics","velocities","velocity","distance","direction","getIntentionalDisplacement","threshold","abs","constant","dimension","rubberband2","rubberbandIfOutOfBounds","position","min","max","minMax","rubberband","noop","chainFns","fns","args","fn","def","array","withDefault","value","matchKeysFromObject","obj","matchingObject","o","Object","key","valueFn","getInitialState","initialCommon","_active","_blocked","_intentional","_movement","_initial","_lastEventType","event","values","offset","lastOffset","initial","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","undefined","initialCoordinates","axis","xy","vxvy","initialDistanceAngle","da","vdva","origin","turns","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","buttons","down","shiftKey","altKey","metaKey","ctrlKey","drag","_isTap","_delayedEvent","tap","swipe","pinch","wheel","move","scroll","setListeners","action","add","listeners","eventName","el","supportsGestureEvents","addListeners","removeListeners","getModifierKeys","changedTouches","getGenericEventData","touchEvents","getTouchEvents","getScrollEventValues","scrollX","scrollY","scrollLeft","scrollTop","currentTarget","getWheelEventValues","deltaX","deltaY","getPointerEventValues","clientX","clientY","WEBKIT_DISTANCE_SCALE_FACTOR","getWebkitGestureEventValues","getTwoTouchesEventData","dx","dy","Controller","domTarget","config","eventNamesArray","bindings","captureString","fnsArray","useRecognizers","handlers","classes","nativeHandlers","controller","current","bind","RecognizerClass","nativeRefs","React","Recognizer","updateSharedState","updateGestureState","ms","clearTimeout","getGenericPayload","type","state","isStartEvent","checkIntentionality","getMovement","t0","t1","intentional","prevMovement","i0","i1","_m0","_m1","intentionalityCheck","_i0","_i1","_rubberband","bounds","clean","intentionalX","intentionalY","newMemo","CoordinatesRecognizer","getInternalMovement","_ix","_iy","intentionalMovement","absX","absY","configAxis","lockDirection","lockedIndex","getKinematics","movementDetection","kinematics","mapStateValues","TAP_DISTANCE_THRESHOLD","SWIPE_MAX_ELAPSED_TIME","FILTER_REPEATED_EVENTS_DELAY","DragRecognizer","delay","pointerId","dragListeners","isTouch","startDrag","startState","genericEventData","vx","vy","mx","my","ix","iy","endState","swipeVelocity","svx","svy","swipeDistance","sx","sy","requestAnimationFrame","addBindings","DEFAULT_DRAG_DELAY","DEFAULT_RUBBERBAND","DEFAULT_SWIPE_VELOCITY","DEFAULT_SWIPE_DISTANCE","defaultWindow","defaultCoordinatesOptions","getInternalGenericOptions","eventOptions","passive","capture","pointer","window","enabled","restConfig","getInternalGestureOptions","gestureConfig","getInternalCoordinatesOptions","coordinatesConfig","internalOptions","boundsArray","getInternalDistanceAngleOptions","distanceAngleConfig","distanceBounds","angleBounds","getInternalDragOptions","dragConfig","dragOptions","filterTaps","internalCoordinatesOptions","useDrag","handler","mergedConfig","DistanceAngleRecognizer","d","a","delta_a","newTurns","movement_d","movement_a","PinchRecognizer","delta_d","prev_d","prev_a","process","console","usePinch","WheelRecognizer","prevValues","useWheel","MoveRecognizer","useMove","useHover","hover","ScrollRecognizer","useScroll","useGesture","actions","k","internalHandlers","_nativeHandlers","includeStartEndHandlers","startKey","handlerKey","endKey"],"mappings":"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","sourcesContent":["// vector add\nexport function addV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v + v2[i]) as T\n}\n\n// vector substract\nexport function subV<T extends number[]>(v1: T, v2: T): T {\n  return v1.map((v, i) => v - v2[i]) as T\n}\n/**\n * Calculates velocity\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @param len the length of the delta vector\n * @returns velocity\n */\nexport function calculateVelocity(delta: number[], delta_t: number, len: number): number {\n  len = len || Math.hypot(...delta)\n  return delta_t ? len / delta_t : 0\n}\n\n/**\n * Calculates velocities vector\n * @template T the expected vector type\n * @param delta the difference between current and previous vectors\n * @param delta_t the time offset\n * @returns velocities vector\n */\nexport function calculateVelocities<T extends number[]>(delta: T, delta_t: number): T {\n  return (delta_t ? delta.map(v => v / delta_t) : Array(delta.length).fill(0)) as T\n}\n\n/**\n * Calculates distance\n * @param movement the difference between current and initial vectors\n * @returns distance\n */\nexport function calculateDistance(movement: number[]): number {\n  return Math.hypot(...movement)\n}\n\n/**\n * Calculates direction\n * @template T the expected vector type\n * @param delta\n * @param len\n * @returns direction\n */\nexport function calculateDirection<T extends number[]>(delta: T, len?: number): T {\n  len = len || Math.hypot(...delta) || 1\n  return delta.map(v => v / len!) as T\n}\n\ninterface Kinematics<T extends number[]> {\n  velocities: T\n  velocity: number\n  distance: number\n  direction: T\n}\n\n/**\n * Calculates all kinematics\n * @template T the expected vector type\n * @param movement the difference between current and initial vectors\n * @param delta the difference between current and previous vectors\n * @param delta_t the time difference between current and previous timestamps\n * @returns all kinematics\n */\nexport function calculateAllKinematics<T extends number[]>(movement: T, delta: T, delta_t: number): Kinematics<T> {\n  const len = Math.hypot(...delta)\n\n  return {\n    velocities: calculateVelocities(delta, delta_t),\n    velocity: calculateVelocity(delta, delta_t, len),\n    distance: calculateDistance(movement),\n    direction: calculateDirection(delta, len),\n  }\n}\n\nexport function getIntentionalDisplacement(movement: number, threshold: number): number | false {\n  const abs = Math.abs(movement)\n  return abs >= threshold ? Math.sign(movement) * threshold : false\n}\n\nfunction minMax(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(value, max))\n}\n\n// Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\nfunction rubberband2(distance: number, constant: number) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5)\n}\n\nfunction rubberband(distance: number, dimension: number, constant: number) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant)\n  return (distance * dimension * constant) / (dimension + constant * distance)\n}\n\nexport function rubberbandIfOutOfBounds(position: number, min: number, max: number, constant = 0.15) {\n  if (constant === 0) return minMax(position, min, max)\n\n  if (position < min) {\n    return -rubberband(min - position, max - min, constant) + min\n  }\n  if (position > max) {\n    return rubberband(position - max, max - min, constant) + max\n  }\n  return position\n}\n","import { Fn, Vector2 } from '../types'\n\n// blank function\nexport function noop() {}\n// returns a function that chains all functions given as parameters\nexport const chainFns = (...fns: Fn[]): Fn => (...args: any[]) => fns.forEach(fn => fn(...args))\n\nexport const def = {\n  array: <T>(value: T | T[]): T[] => (Array.isArray(value) ? value : [value, value]),\n  withDefault: <T>(value: T | undefined, defaultIfUndefined: T): T => (value !== void 0 ? value : defaultIfUndefined),\n}\n\nexport function matchKeysFromObject<T extends object, K extends object>(obj: T, matchingObject: K): Partial<T> {\n  const o: Partial<T> = {}\n  Object.entries(obj).forEach(\n    ([key, value]) => (value !== void 0 || key in matchingObject) && (o[key as keyof T] = value)\n  )\n  return o\n}\n\nexport function valueFn(v: Vector2 | (() => Vector2)) {\n  return typeof v === 'function' ? v() : v\n}\n","import { noop } from './utils'\nimport { CommonGestureState, Coordinates, State, DistanceAngle, Vector2 } from '../types'\n\nexport function getInitialState(): State {\n  // common initial state for all gestures\n  const initialCommon: CommonGestureState = {\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined,\n  }\n\n  // initial state for coordinates-based gestures\n  const initialCoordinates: Coordinates = {\n    axis: undefined,\n    xy: [0, 0] as Vector2,\n    vxvy: [0, 0] as Vector2,\n    velocity: 0,\n    distance: 0,\n  }\n\n  // initial state for distance and angle-based gestures (pinch)\n  const initialDistanceAngle: DistanceAngle = {\n    da: [0, 0] as Vector2,\n    vdva: [0, 0] as Vector2,\n    origin: undefined,\n    turns: 0,\n  }\n\n  // initial state object (used by the gesture controller)\n  return {\n    shared: {\n      hovering: false,\n      scrolling: false,\n      wheeling: false,\n      dragging: false,\n      moving: false,\n      pinching: false,\n      touches: 0,\n      buttons: 0,\n      down: false,\n      shiftKey: false,\n      altKey: false,\n      metaKey: false,\n      ctrlKey: false,\n    },\n    drag: {\n      ...initialCommon,\n      ...initialCoordinates,\n      _isTap: true,\n      _delayedEvent: false,\n      tap: false,\n      swipe: [0, 0],\n    },\n    pinch: { ...initialCommon, ...initialDistanceAngle },\n    wheel: { ...initialCommon, ...initialCoordinates },\n    move: { ...initialCommon, ...initialCoordinates },\n    scroll: { ...initialCommon, ...initialCoordinates },\n  }\n}\n","import { Fn, EventOptions, UseGestureEvent, Vector2, WebKitGestureEvent } from '../types'\n\nconst isBrowser = typeof window !== 'undefined'\n\nexport const supportsTouchEvents = () => isBrowser && window.ontouchstart === null\n\nconst setListeners = (add: boolean) => (el: EventTarget, listeners: [string, Fn][], options: EventOptions): void => {\n  const action = add ? 'addEventListener' : 'removeEventListener'\n  listeners.forEach(([eventName, fn]) => el[action](eventName, fn, options))\n}\n\n/**\n * Whether the browser supports GestureEvent (ie Safari)\n * @returns true if the browser supports gesture event\n */\nexport function supportsGestureEvents(): boolean {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent\n  } catch (e) {\n    return false\n  }\n}\n\nexport const addListeners = setListeners(true)\nexport const removeListeners = setListeners(false)\n\ninterface ModifierKeys {\n  shiftKey: boolean\n  altKey: boolean\n  metaKey: boolean\n  ctrlKey: boolean\n}\n\n/**\n * Gets modifier keys from event\n * @param event\n * @returns modifier keys\n */\nexport function getModifierKeys(event: UseGestureEvent): ModifierKeys {\n  const { shiftKey, altKey, metaKey, ctrlKey } = event\n  return { shiftKey, altKey, metaKey, ctrlKey }\n}\n\nfunction getTouchEvents(event: UseGestureEvent) {\n  if ('touches' in event) {\n    const { touches, changedTouches } = event\n    return touches.length > 0 ? touches : changedTouches\n  }\n  return null\n}\n\nexport function getGenericEventData(event: React.MouseEvent | React.TouchEvent | React.PointerEvent) {\n  const buttons = 'buttons' in event ? event.buttons : 0\n  const touchEvents = getTouchEvents(event)\n  const touches = (touchEvents && touchEvents.length) || 0\n  const down = touches > 0 || buttons > 0\n  return { touches, down, buttons, ...getModifierKeys(event) }\n}\n\ntype Values = { values: Vector2 }\n\n/**\n * Gets scroll event values\n * @param event\n * @returns scroll event values\n */\nexport function getScrollEventValues(event: UseGestureEvent): Values {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  const { scrollX, scrollY, scrollLeft, scrollTop } = event.currentTarget as Element & Window\n  return { values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0] }\n}\n\n/**\n * Gets wheel event values.\n * @param event\n * @returns wheel event values\n */\nexport function getWheelEventValues(event: UseGestureEvent<React.WheelEvent>): Values {\n  const { deltaX, deltaY } = event\n  //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n  return { values: [deltaX, deltaY] }\n}\n\n/**\n * Gets pointer event values.\n * @param event\n * @returns pointer event values\n */\nexport function getPointerEventValues(event: React.MouseEvent | React.TouchEvent | React.PointerEvent): Values {\n  const touchEvents = getTouchEvents(event)\n  const { clientX, clientY } = touchEvents ? touchEvents[0] : (event as React.PointerEvent)\n  return { values: [clientX, clientY] }\n}\n\nconst WEBKIT_DISTANCE_SCALE_FACTOR = 260\n\n/**\n * Gets webkit gesture event values.\n * @param event\n * @returns webkit gesture event values\n */\nexport function getWebkitGestureEventValues(event: WebKitGestureEvent): Values {\n  return { values: [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation] as Vector2 }\n}\n\n/**\n * Gets two touches event data\n * @param event\n * @returns two touches event data\n */\nexport function getTwoTouchesEventData(event: React.TouchEvent) {\n  const { touches } = event\n  const dx = touches[1].clientX - touches[0].clientX\n  const dy = touches[1].clientY - touches[0].clientY\n\n  const values: Vector2 = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI]\n  const origin: Vector2 = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2]\n\n  return { values, origin }\n}\n","import {\n  StateKey,\n  State,\n  Fn,\n  ReactEventHandlerKey,\n  ReactEventHandlers,\n  InternalConfig,\n  InternalHandlers,\n} from './types'\nimport { getInitialState } from './utils/state'\nimport { addListeners, removeListeners } from './utils/event'\nimport { chainFns } from './utils/utils'\n\ntype GestureTimeouts = Partial<{ [stateKey in StateKey]: number }>\ntype WindowListeners = Partial<{ [stateKey in StateKey]: [string, Fn][] }>\ntype Bindings = Partial<{ [eventName in ReactEventHandlerKey]: Fn[] }>\n\n/**\n * The controller will keep track of the state for all gestures and also keep\n * track of timeouts, and window listeners.\n *\n * @template BinderType the type the bind function should return\n */\nexport default class Controller {\n  public config!: InternalConfig\n  public handlers!: Partial<InternalHandlers>\n  public state: State = getInitialState() // state for all gestures\n  public timeouts: GestureTimeouts = {} // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n  private domListeners: [string, Fn][] = [] // when config.domTarget is set, we attach events directly to the dom\n  private windowListeners: WindowListeners = {} // keeps track of window listeners added by gestures (drag only at the moment)\n  private bindings: Bindings = {} // an object holding the handlers associated to the gestures\n\n  /**\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\n   */\n  public clean = (): void => {\n    this.resetBindings()\n    Object.values(this.timeouts).forEach(clearTimeout)\n    Object.keys(this.windowListeners).forEach(stateKey => this.removeWindowListeners(stateKey as StateKey))\n  }\n\n  /**\n   * Function run every time the bind function is run (ie on every render).\n   * Resets the binding object and remove dom listeners attached to config.domTarget\n   */\n  public resetBindings = (): void => {\n    this.bindings = {}\n    const domTarget = this.getDomTarget()\n    if (domTarget) {\n      removeListeners(domTarget, this.domListeners, this.config.eventOptions)\n      this.domListeners = []\n    }\n  }\n\n  /**\n   * Returns the domTarget element and parses a ref if needed.\n   */\n  private getDomTarget = (): EventTarget | null | undefined => {\n    const { domTarget } = this.config\n    return domTarget && 'current' in domTarget ? domTarget.current : domTarget\n  }\n\n  /**\n   * Commodity function to let recognizers simply add listeners to config.window.\n   */\n  public addWindowListeners = (stateKey: StateKey, listeners: [string, Fn][]): void => {\n    if (!this.config.window) return\n    // we use this.windowListeners to keep track of the listeners we add\n    this.windowListeners[stateKey] = listeners\n    addListeners(this.config.window, listeners, this.config.eventOptions)\n  }\n\n  /**\n   * Commodity function to let recognizers simply remove listeners to config.window.\n   */\n  public removeWindowListeners = (stateKey: StateKey): void => {\n    if (!this.config.window) return\n    const listeners = this.windowListeners[stateKey]\n    if (listeners) {\n      removeListeners(this.config.window, listeners, this.config.eventOptions)\n      delete this.windowListeners[stateKey]\n    }\n  }\n\n  /**\n   * When config.domTarget is set, this function will add dom listeners to it\n   */\n  public addDomTargetListeners = (target: EventTarget): void => {\n    /** We iterate on the entries of this.binding for each event, then we chain\n     * the array of functions mapped to it and push them to this.domListeners\n     */\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      this.domListeners.push([event.substr(2).toLowerCase(), chainFns(...(fns as Fn[]))])\n    })\n\n    addListeners(target, this.domListeners, this.config.eventOptions)\n  }\n\n  /**\n   * this.bindings is an object which keys match ReactEventHandlerKeys.\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\n   * that key.\n   */\n  public addBindings = (eventNames: ReactEventHandlerKey | ReactEventHandlerKey[], fn: Fn): void => {\n    const eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames\n    eventNamesArray.forEach(eventName => {\n      if (this.bindings[eventName]) this.bindings[eventName]!.push(fn)\n      else this.bindings[eventName] = [fn]\n    })\n  }\n\n  /**\n   * getBindings will return an object that will be bound by users\n   * to the react component they want to interact with.\n   */\n  public getBindings = (): ReactEventHandlers => {\n    const bindings: ReactEventHandlers = {}\n    const { captureString } = this.config\n\n    Object.entries(this.bindings).forEach(([event, fns]) => {\n      const fnsArray = Array.isArray(fns) ? fns : [fns]\n      const key = (event + captureString) as ReactEventHandlerKey\n      bindings[key] = chainFns(...(fnsArray as Fn[]))\n    })\n\n    return bindings\n  }\n\n  public getBind = () => {\n    // If config.domTarget is set we add event listeners to it and return the clean function.\n    if (this.config.domTarget) {\n      const domTarget = this.getDomTarget()\n      domTarget && this.addDomTargetListeners(domTarget)\n      return this.clean\n    }\n\n    // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n    return this.getBindings()\n  }\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport React from 'react'\nimport Controller from '../Controller'\nimport {\n  InternalConfig,\n  HookReturnType,\n  InternalHandlers,\n  RecognizerClasses,\n  GenericOptions,\n  NativeHandlersPartial,\n  ReactEventHandlerKey,\n  Fn,\n} from '../types'\n/**\n * @private\n *\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\n *\n * @param {Partial<InternalHandlers>} handlers\n * @param {RecognizerClasses} classes\n * @param {InternalConfig} config\n * @param {NativeHandlersPartial} nativeHandlers - native handlers such as onClick, onMouseDown, etc.\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport default function useRecognizers<Config extends Partial<GenericOptions>>(\n  handlers: Partial<InternalHandlers>,\n  classes: RecognizerClasses,\n  config: InternalConfig,\n  nativeHandlers?: NativeHandlersPartial\n): (...args: any[]) => HookReturnType<Config> {\n  // The gesture controller keeping track of all gesture states\n  const controller = React.useMemo(() => {\n    const current = new Controller()\n\n    /**\n     * The bind function will create gesture recognizers and return the right\n     * bind object depending on whether `domTarget` was specified in the config object.\n     */\n    const bind = (...args: any[]) => {\n      current.resetBindings()\n      for (let RecognizerClass of classes) {\n        new RecognizerClass(current, args).addBindings()\n      }\n\n      // we also add event bindings for native handlers\n      if (controller.nativeRefs) {\n        for (let eventName in controller.nativeRefs)\n          current.addBindings(\n            eventName as ReactEventHandlerKey,\n            // @ts-ignore we're cheating when it comes to event type :(\n            controller.nativeRefs[eventName] as Fn\n          )\n      }\n\n      return current.getBind() as HookReturnType<Config>\n    }\n\n    return { nativeRefs: nativeHandlers, current, bind }\n  }, [])\n\n  // We reassign the config and handlers to the controller on every render.\n  controller.current!.config = config\n  controller.current!.handlers = handlers\n  // We assign nativeHandlers, otherwise they won't be refreshed on the next render.\n  controller.nativeRefs = nativeHandlers\n\n  // Run controller clean functions on unmount.\n  React.useEffect(() => controller.current!.clean, [])\n\n  return controller.bind\n}\n","import Controller from '../Controller'\nimport {\n  StateKey,\n  SharedGestureState,\n  Fn,\n  UseGestureEvent,\n  IngKey,\n  InternalConfig,\n  GestureState,\n  PartialGestureState,\n  Vector2,\n  FalseOrNumber,\n  FullGestureState,\n} from '../types'\nimport { getInitialState } from '../utils/state'\nimport { subV, addV, getIntentionalDisplacement, rubberbandIfOutOfBounds } from '../utils/math'\nimport { valueFn } from '../utils/utils'\n\n/**\n * @private\n * Recognizer abstract class.\n *\n * @protected\n * @abstract\n * @type {StateKey<T>} whether the Recognizer should deal with coordinates or distance / angle\n */\nexport default abstract class Recognizer<T extends StateKey> {\n  protected abstract ingKey: IngKey // dragging, scrolling, etc.\n  protected debounced: Boolean = true\n\n  /**\n   * Creates an instance of a gesture recognizer.\n   * @param stateKey drag, move, pinch, etc.\n   * @param controller the controller attached to the gesture\n   * @param [args] the args that should be passed to the gesture handler\n   */\n  constructor(\n    protected readonly stateKey: T,\n    protected readonly controller: Controller,\n    protected readonly args: any[] = []\n  ) {}\n\n  // Returns the gesture config\n  protected get config(): NonNullable<InternalConfig[T]> {\n    return this.controller.config[this.stateKey]!\n  }\n\n  // Is the gesture enabled\n  protected get enabled(): boolean {\n    return this.controller.config.enabled && this.config.enabled\n  }\n\n  // Returns the controller state for a given gesture\n  protected get state(): GestureState<T> {\n    return this.controller.state[this.stateKey]\n  }\n\n  // Returns the gesture handler\n  protected get handler() {\n    return this.controller.handlers[this.stateKey]!\n  }\n\n  // Conveninence method to update the shared state\n  protected updateSharedState(sharedState: Partial<SharedGestureState> | null) {\n    Object.assign(this.controller.state.shared, sharedState)\n  }\n\n  // Conveninence method to update the gesture state\n  protected updateGestureState(gestureState: PartialGestureState<T> | null) {\n    Object.assign(this.state, gestureState)\n  }\n\n  // Convenience method to set a timeout for a given gesture\n  protected setTimeout = (callback: (...args: any[]) => void, ms: number = 140, ...args: any[]): void => {\n    this.controller.timeouts[this.stateKey] = window.setTimeout(callback, ms, ...args)\n  }\n\n  // Convenience method to clear a timeout for a given gesture\n  protected clearTimeout = () => {\n    clearTimeout(this.controller.timeouts[this.stateKey])\n  }\n\n  // Convenience method to add window listeners for a given gesture\n  protected addWindowListeners = (listeners: [string, Fn][]) => {\n    this.controller.addWindowListeners(this.stateKey, listeners)\n  }\n\n  // Convenience method to remove window listeners for a given gesture\n  protected removeWindowListeners = () => {\n    this.controller.removeWindowListeners(this.stateKey)\n  }\n\n  /**\n   * Utility function to get kinematics of the gesture.\n   *\n   * @abstract\n   * @values - values we want to calculate the kinematics from\n   * @event - the pointer event\n   * @returns - set of values including movement, velocity, velocities, distance and direction\n   */\n  protected abstract getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T>\n\n  protected abstract mapStateValues(state: GestureState<T>): PartialGestureState<T>\n\n  // Should return the bindings to be added for a given gesture\n  public abstract addBindings(): void\n\n  /**\n   * Returns a generic, common payload for all gestures from an event.\n   *\n   * @param {UseGestureEvent} event\n   * @param {boolean} [isStartEvent]\n   * @returns - the generic gesture payload\n   */\n  protected getGenericPayload(event: UseGestureEvent, isStartEvent?: boolean) {\n    const { timeStamp, type } = event\n    const { values, startTime } = this.state\n\n    return {\n      _lastEventType: type,\n      event,\n      timeStamp,\n      elapsedTime: isStartEvent ? 0 : timeStamp - startTime!,\n      args: this.args,\n      previous: values,\n    }\n  }\n  /**\n   * Returns the reinitialized start state for the gesture.\n   * Should be common to all gestures.\n   *\n   * @param {Vector2} values\n   * @param {UseGestureEvent} event\n   * @returns - the start state for the gesture\n   */\n  protected getStartGestureState = (values: Vector2, event: UseGestureEvent) => {\n    return {\n      ...getInitialState()[this.stateKey],\n      _active: true,\n      values,\n      initial: values,\n      offset: this.state.offset,\n      lastOffset: this.state.offset,\n      startTime: event.timeStamp,\n    }\n  }\n\n  /**\n   * Returns state properties depending on the movement and state.\n   *\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\n   * below.\n   */\n  protected checkIntentionality(\n    _intentional: [FalseOrNumber, FalseOrNumber],\n    _movement: Vector2,\n    _state: PartialGestureState<T>\n  ): PartialGestureState<T> {\n    return { _intentional, _blocked: false } as PartialGestureState<T>\n  }\n\n  protected abstract getInternalMovement(values: Vector2, state: GestureState<T>): Vector2\n\n  /**\n   * Returns basic movement properties for the gesture based on the next values and current state.\n   */\n  protected getMovement(values: Vector2, state: GestureState<T> = this.state): PartialGestureState<T> {\n    const { initial, threshold, rubberband } = this.config\n\n    const [t0, t1] = threshold\n\n    const { _initial, _active, _intentional: intentional, lastOffset, movement: prevMovement } = state\n    let [i0, i1] = intentional\n\n    const [_m0, _m1] = this.getInternalMovement(values, state)\n\n    /**\n     * For both dimensions of the gesture, check its intentionality on each frame.\n     */\n    if (i0 === false) {\n      i0 = getIntentionalDisplacement(_m0, t0)\n    }\n    if (i1 === false) {\n      i1 = getIntentionalDisplacement(_m1, t1)\n    }\n\n    // Get gesture specific state properties based on intentionality and movement.\n    const intentionalityCheck = this.checkIntentionality([i0, i1], [_m0, _m1], state)\n\n    const { _intentional, _blocked } = intentionalityCheck\n    const [_i0, _i1] = _intentional!\n    const _movement = [_m0, _m1]\n\n    if (_i0 !== false && intentional[0] === false) _initial[0] = valueFn(initial)[0]\n    if (_i1 !== false && intentional[1] === false) _initial[1] = valueFn(initial)[1]\n\n    /**\n     * If the gesture has been blocked (from gesture specific checkIntentionality),\n     * stop right there.\n     */\n    if (_blocked) return { ...intentionalityCheck, _movement, delta: [0, 0] }\n\n    /**\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\n     * It is calculated from the actual movement minus the threshold.\n     */\n    let movement = [\n      _i0 !== false ? _m0 - _i0 : valueFn(initial)[0],\n      _i1 !== false ? _m1 - _i1 : valueFn(initial)[1],\n    ] as Vector2\n    const offset = addV(movement, lastOffset)\n\n    /**\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\n     * and offset can return within their bounds.\n     */\n    const _rubberband: Vector2 = _active ? rubberband : [0, 0]\n    movement = this.rubberband(addV(movement, _initial), _rubberband) // rubberbanded movement\n\n    return {\n      ...intentionalityCheck,\n      _initial,\n      _movement,\n      movement,\n      offset: this.rubberband(offset, _rubberband), // rubberbanded offset\n      delta: subV(movement, prevMovement),\n    } as PartialGestureState<T>\n  }\n\n  // Runs rubberband on a vector\n  protected rubberband = (vector: Vector2, rubberband: Vector2): Vector2 => {\n    const { bounds } = this.config\n\n    /**\n     * [x, y]: [rubberband(x, min, max), rubberband(y, min, max)]\n     */\n    return vector.map((v, i) => rubberbandIfOutOfBounds(v, bounds[i][0], bounds[i][1], rubberband[i])) as Vector2\n  }\n\n  // Cleans the gesture. Can be overriden by gestures.\n  protected clean() {\n    this.clearTimeout()\n    this.removeWindowListeners()\n  }\n\n  /**\n   * Fires the gesture handler\n   *\n   * @param {boolean} [forceFlag] - if true, then the handler will fire even if the gesture is not intentional\n   */\n  protected fireGestureHandler = (forceFlag?: boolean): FullGestureState<T> | null => {\n    /**\n     * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\n     * clean everything and don't do anything.\n     */\n    if (this.state._blocked) {\n      // we need debounced gestures to end by themselves\n      if (!this.debounced) {\n        this.state._active = false\n        this.clean()\n      }\n      return null\n    }\n\n    // If the gesture has no intentional dimension, don't do fire the handler.\n    const [intentionalX, intentionalY] = this.state._intentional\n    if (!forceFlag && intentionalX === false && intentionalY === false) return null\n\n    const { _active, active } = this.state\n\n    this.state.active = _active\n    this.state.first = _active && !active // `first` is true when the gesture becomes active\n    this.state.last = active && !_active // `last` is true when the gesture becomes inactive\n\n    this.controller.state.shared[this.ingKey] = _active // Sets dragging, pinching, etc. to the gesture active state\n\n    const state = {\n      ...this.controller.state.shared,\n      ...this.state,\n      ...this.mapStateValues(this.state), // Sets xy or da to the gesture state values\n    } as FullGestureState<T>\n\n    // @ts-ignore\n    const newMemo = this.handler(state)\n\n    // Sets memo to the returned value of the handler (unless it's not undefined)\n    this.state.memo = newMemo !== void 0 ? newMemo : this.state.memo\n\n    // Cleans the gesture when the gesture is no longer active.\n    if (!_active) this.clean()\n\n    return state\n  }\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics, subV } from '../utils/math'\nimport { Vector2, UseGestureEvent, PartialGestureState, FalseOrNumber, GestureState, CoordinatesKey } from '../types'\n\n/**\n * @private\n * Abstract class for coordinates-based gesture recongizers\n * @abstract\n * @class CoordinatesRecognizer\n * @extends {Recognizer<T>}\n * @template T\n */\nexport default abstract class CoordinatesRecognizer<T extends CoordinatesKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement(values: Vector2, state: GestureState<T>): Vector2 {\n    return subV(values, state.initial)\n  }\n\n  /**\n   * In coordinates-based gesture, this function will detect the first intentional axis,\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\n   * if the first intentional axis doesn't match the specified axis in config.\n   *\n   * @param {[FalseOrNumber, FalseOrNumber]} _intentional\n   * @param {Vector2} _movement\n   * @param {PartialGestureState<T>} state\n   */\n  protected checkIntentionality(\n    _intentional: [FalseOrNumber, FalseOrNumber],\n    _movement: Vector2,\n    state: PartialGestureState<T>\n  ): PartialGestureState<T> {\n    let [_ix, _iy] = _intentional\n    const intentionalMovement = _ix !== false || _iy !== false\n    let { axis } = state\n    let _blocked = false\n\n    // If the movement is intentional, we can compute axis.\n    if (intentionalMovement) {\n      const [absX, absY] = _movement.map(Math.abs)\n\n      const { axis: configAxis, lockDirection } = this.config\n\n      // We make sure we only set axis value if it hadn't been detected before.\n      axis = axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined)\n      if (!!configAxis || lockDirection) {\n        if (!!axis) {\n          // If the detected axis doesn't match the config axis we block the gesture\n          if (!!configAxis && axis !== configAxis) _blocked = true\n          else {\n            // Otherwise we prevent the gesture from updating the unwanted axis.\n            const lockedIndex = axis === 'x' ? 1 : 0\n            _intentional![lockedIndex] = false\n          }\n        } else {\n          // Until we've detected the axis, we prevent the hnadler from updating.\n          _intentional = [false, false]\n        }\n      }\n    }\n\n    return { _intentional, _blocked, axis } as PartialGestureState<T>\n  }\n\n  getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T> {\n    const { timeStamp } = this.state\n\n    const movementDetection = this.getMovement(values, this.state)\n    const { _blocked, delta, movement } = movementDetection\n\n    if (_blocked) return movementDetection\n\n    const delta_t = event.timeStamp - timeStamp!\n    const kinematics = calculateAllKinematics(movement!, delta!, delta_t)\n\n    return {\n      values,\n      delta,\n      ...movementDetection,\n      ...kinematics,\n    }\n  }\n\n  protected mapStateValues(state: GestureState<T>): PartialGestureState<T> {\n    return { xy: state.values, vxvy: state.velocities } as PartialGestureState<T>\n  }\n}\n","import { PointerEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, Fn, IngKey } from '../types'\nimport { noop } from '../utils/utils'\nimport { getPointerEventValues, getGenericEventData } from '../utils/event'\nimport { calculateDistance } from '../utils/math'\n\nconst TAP_DISTANCE_THRESHOLD = 3\nconst SWIPE_MAX_ELAPSED_TIME = 220\nconst FILTER_REPEATED_EVENTS_DELAY = 200\n\nexport default class DragRecognizer extends CoordinatesRecognizer<'drag'> {\n  ingKey = 'dragging' as IngKey\n  wasTouch = false\n\n  constructor(controller: Controller, args: any[]) {\n    super('drag', controller, args)\n  }\n\n  private isEventTypeTouch = (type?: string) => !!type && type.indexOf('touch') === 0\n\n  private dragShouldStart = (event: UseGestureEvent) => {\n    const { touches } = getGenericEventData(event)\n    const { _lastEventType } = this.state\n    /**\n     * This tries to filter out mouse events triggered by touch screens\n     * */\n    // If the previous gesture was touch-based, and the current one is mouse based,\n    // this means that we might be dealing with mouse simulated events if they're close to\n    // each other. We're only doing this check when we're not using pointer events.\n    if (\n      !this.controller.config.pointer &&\n      this.isEventTypeTouch(_lastEventType) &&\n      !this.isEventTypeTouch(event.type)\n    ) {\n      const delay = Math.abs(event.timeStamp - this.state.startTime)\n      if (delay < FILTER_REPEATED_EVENTS_DELAY) return false\n    }\n\n    return this.enabled && touches < 2\n  }\n\n  private setPointers = (event: UseGestureEvent<PointerEvent>) => {\n    const { currentTarget, pointerId } = event\n    if (currentTarget) currentTarget.setPointerCapture(pointerId)\n    this.updateGestureState({ currentTarget, pointerId })\n  }\n\n  private removePointers = () => {\n    const { currentTarget, pointerId } = this.state\n    if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId)\n  }\n\n  private setListeners = (isTouch: boolean) => {\n    this.removeWindowListeners()\n    const dragListeners: [string, Fn][] = isTouch\n      ? [\n          ['touchmove', this.onDragChange],\n          ['touchend', this.onDragEnd],\n          ['touchcancel', this.onDragEnd],\n        ]\n      : [\n          ['mousemove', this.onDragChange],\n          ['mouseup', this.onDragEnd],\n        ]\n    this.addWindowListeners(dragListeners)\n  }\n\n  onDragStart = (event: UseGestureEvent): void => {\n    if (!this.dragShouldStart(event)) return\n    // if pointers events\n    if (this.controller.config.pointer) this.setPointers(event as PointerEvent)\n    else this.setListeners(this.isEventTypeTouch(event.type))\n\n    if (this.config.delay > 0) {\n      this.state._delayedEvent = true\n      if (typeof event.persist === 'function') event.persist()\n      this.setTimeout(() => this.startDrag(event), this.config.delay)\n    } else {\n      this.startDrag(event)\n    }\n  }\n\n  startDrag(event: UseGestureEvent) {\n    const { values } = getPointerEventValues(event)\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onDragChange = (event: UseGestureEvent): void => {\n    const { canceled } = this.state\n    if (canceled) return\n\n    if (!this.state._active) {\n      if (this.state._delayedEvent) {\n        this.clearTimeout()\n        this.startDrag(event)\n      }\n      return\n    }\n\n    const genericEventData = getGenericEventData(event)\n\n    if (!genericEventData.down) {\n      this.onDragEnd(event)\n      return\n    }\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getPointerEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    let { _isTap } = this.state\n    if (_isTap && calculateDistance(kinematics._movement!) >= TAP_DISTANCE_THRESHOLD) _isTap = false\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      _isTap,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onDragEnd = (event: UseGestureEvent): void => {\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n\n    const {\n      _isTap,\n      values,\n      velocities: [vx, vy],\n      movement: [mx, my],\n      _intentional: [ix, iy],\n    } = this.state\n\n    const endState = {\n      ...this.getGenericPayload(event),\n      ...this.getMovement(values),\n    }\n\n    const { elapsedTime } = endState\n\n    const {\n      swipeVelocity: [svx, svy],\n      swipeDistance: [sx, sy],\n    } = this.config\n\n    const swipe: [number, number] = [0, 0]\n\n    if (elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n      if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = Math.sign(vx)\n      if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = Math.sign(vy)\n    }\n\n    this.updateGestureState({\n      event,\n      ...endState,\n      tap: _isTap,\n      swipe,\n    })\n    this.fireGestureHandler(this.config.filterTaps && this.state._isTap)\n  }\n\n  clean = (): void => {\n    super.clean()\n    this.state._delayedEvent = false\n\n    if (this.controller.config.pointer) this.removePointers()\n  }\n\n  onCancel = (): void => {\n    this.updateGestureState({ canceled: true, cancel: noop })\n    this.state._active = false\n    this.updateSharedState({ down: false, buttons: 0, touches: 0 })\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n\n  addBindings(): void {\n    if (this.controller.config.pointer) {\n      this.controller.addBindings('onPointerDown', this.onDragStart)\n      this.controller.addBindings('onPointerMove', this.onDragChange)\n      this.controller.addBindings(['onPointerUp', 'onPointerCancel'], this.onDragEnd)\n    } else {\n      this.controller.addBindings(['onTouchStart', 'onMouseDown'], this.onDragStart)\n    }\n  }\n}\n","import { def, matchKeysFromObject } from './utils'\nimport {\n  Vector2,\n  GenericOptions,\n  InternalGenericOptions,\n  DragConfig,\n  Tuple,\n  GestureOptions,\n  InternalDragOptions,\n  InternalGestureOptions,\n  CoordinatesConfig,\n  CoordinatesOptions,\n  InternalCoordinatesOptions,\n  DistanceAngleConfig,\n  InternalDistanceAngleOptions,\n} from '../types'\n\nconst DEFAULT_DRAG_DELAY = 180\nconst DEFAULT_RUBBERBAND = 0.15\nconst DEFAULT_SWIPE_VELOCITY = 0.5\nconst DEFAULT_SWIPE_DISTANCE = 60\n\nconst defaultWindow = typeof window !== 'undefined' ? window : undefined\n\nconst defaultCoordinatesOptions: CoordinatesOptions = {\n  lockDirection: false,\n  axis: undefined,\n  bounds: undefined,\n}\n\n/**\n * @private\n *\n * Returns the internal generic option object.\n *\n * @param {Partial<GenericOptions>} [config={}]\n * @returns {InternalGenericOptions}\n */\nexport function getInternalGenericOptions(config: Partial<GenericOptions> = {}): InternalGenericOptions {\n  let {\n    eventOptions: { passive = true, capture = false, pointer = false } = {},\n    window = defaultWindow,\n    domTarget = undefined,\n    enabled = true,\n    ...restConfig\n  } = config\n\n  return {\n    ...restConfig,\n    enabled,\n    domTarget,\n    window,\n    // passive is always true if there's no domTarget\n    eventOptions: { passive: !domTarget || !!passive, capture: !!capture },\n    captureString: capture ? 'Capture' : '',\n    pointer: !!pointer,\n  }\n}\n\nexport function getInternalGestureOptions(gestureConfig: Partial<GestureOptions>): InternalGestureOptions {\n  let { threshold = undefined, rubberband = 0, enabled = true, initial = [0, 0] } = gestureConfig\n\n  if (typeof rubberband === 'boolean') rubberband = rubberband ? DEFAULT_RUBBERBAND : 0\n  if (threshold === void 0) threshold = 0\n\n  return {\n    enabled,\n    initial,\n    threshold: def.array(threshold) as Vector2,\n    rubberband: def.array(rubberband) as Vector2,\n  }\n}\n\nexport function getInternalCoordinatesOptions(coordinatesConfig: CoordinatesConfig = {}): InternalCoordinatesOptions {\n  const { axis, lockDirection, bounds = {}, ...internalOptions } = coordinatesConfig\n\n  const boundsArray = [\n    [def.withDefault(bounds.left, -Infinity), def.withDefault(bounds.right, Infinity)],\n    [def.withDefault(bounds.top, -Infinity), def.withDefault(bounds.bottom, Infinity)],\n  ]\n\n  return {\n    ...getInternalGestureOptions(internalOptions),\n    ...defaultCoordinatesOptions,\n    ...matchKeysFromObject({ axis, lockDirection }, coordinatesConfig),\n    bounds: boundsArray as Tuple<Vector2>,\n  }\n}\n\nexport function getInternalDistanceAngleOptions(\n  distanceAngleConfig: DistanceAngleConfig = {}\n): InternalDistanceAngleOptions {\n  const { distanceBounds = {}, angleBounds = {}, ...internalOptions } = distanceAngleConfig\n\n  const boundsArray = [\n    [def.withDefault(distanceBounds.min, -Infinity), def.withDefault(distanceBounds.max, Infinity)],\n    [def.withDefault(angleBounds.min, -Infinity), def.withDefault(angleBounds.max, Infinity)],\n  ]\n\n  return {\n    ...getInternalGestureOptions(internalOptions),\n    bounds: boundsArray as Tuple<Vector2>,\n  }\n}\n\nexport function getInternalDragOptions(dragConfig: DragConfig = {}): InternalDragOptions {\n  let { enabled, threshold, bounds, rubberband, initial, ...dragOptions } = dragConfig\n  let {\n    swipeVelocity = DEFAULT_SWIPE_VELOCITY,\n    swipeDistance = DEFAULT_SWIPE_DISTANCE,\n    delay = false,\n    filterTaps = false,\n    axis,\n    lockDirection,\n  } = dragOptions\n\n  if (threshold === void 0) {\n    threshold = Math.max(0, filterTaps ? 3 : 0, lockDirection || axis ? 1 : 0)\n  } else {\n    filterTaps = true\n  }\n\n  const internalCoordinatesOptions = getInternalCoordinatesOptions(\n    matchKeysFromObject({ enabled, threshold, bounds, rubberband, axis, lockDirection, initial }, dragConfig)\n  )\n\n  return {\n    ...internalCoordinatesOptions,\n    filterTaps: filterTaps || internalCoordinatesOptions.threshold[0] + internalCoordinatesOptions.threshold[1] > 0,\n    swipeVelocity: def.array(swipeVelocity) as Vector2,\n    swipeDistance: def.array(swipeDistance) as Vector2,\n    delay: typeof delay === 'number' ? delay : delay ? DEFAULT_DRAG_DELAY : 0,\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseDragConfig } from '../types'\nimport { getInternalGenericOptions, getInternalDragOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Drag hook.\n *\n * @param {Handler<'drag'>} handler - the function fired every time the drag gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and drag options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useDrag<Config extends UseDragConfig>(\n  handler: Handler<'drag'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...drag } = config as UseDragConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    drag: getInternalDragOptions(drag),\n  }\n\n  return useRecognizers<Config>({ drag: handler }, [DragRecognizer], mergedConfig)\n}\n","import Recognizer from './Recognizer'\nimport { calculateAllKinematics } from '../utils/math'\nimport { Vector2, UseGestureEvent, PartialGestureState, DistanceAngleKey, GestureState } from '../types'\n\n/**\n * @private\n * Abstract class for distance/angle-based gesture recongizers\n * @abstract\n * @class DistanceAngleRecognizer\n * @extends {Recognizer<T>}\n * @template T\n */\nexport default abstract class DistanceAngleRecognizer<T extends DistanceAngleKey> extends Recognizer<T> {\n  /**\n   * Returns the real movement (without taking intentionality into acount)\n   */\n  protected getInternalMovement([d, a]: [number, number?], state: GestureState<T>): Vector2 {\n    const { values: da, turns, initial } = state\n\n    // angle might not be defined when ctrl wheel is used for zoom only\n    // in that case we set it to the previous angle value\n    a = a !== void 0 ? a : da[1]\n\n    let delta_a = a - da[1]\n\n    /**\n     * The angle value might jump from 179deg to -179deg when we actually want to\n     * read 181deg to ensure continuity. To make that happen, we detect when the jump\n     * is supsiciously high (ie > 270deg) and increase the `turns` value\n     */\n    const newTurns = Math.abs(delta_a) > 270 ? turns + Math.sign(delta_a) : turns\n\n    // we update the angle difference to its corrected value\n\n    const movement_d = d - initial[0]\n    const movement_a = a - 360 * newTurns - initial[1]\n    return [movement_d, movement_a]\n  }\n\n  getKinematics(values: Vector2, event: UseGestureEvent): PartialGestureState<T> {\n    const { timeStamp, initial } = this.state\n\n    const movementDetection = this.getMovement(values, this.state)\n    const { delta, movement } = movementDetection\n\n    const turns = (values[1] - movement![1] - initial[1]) / 360\n\n    const delta_t = event.timeStamp - timeStamp!\n    const kinematics = calculateAllKinematics(movement!, delta!, delta_t)\n\n    return {\n      values,\n      delta,\n      turns,\n      ...movementDetection,\n      ...kinematics,\n    }\n  }\n\n  protected mapStateValues(state: GestureState<T>): PartialGestureState<T> {\n    return { da: state.values, vdva: state.velocities } as PartialGestureState<T>\n  }\n}\n","import { TouchEvent, WheelEvent } from 'react'\nimport DistanceAngleRecognizer from './DistanceAngleRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey, Vector2, WebKitGestureEvent } from '../types'\nimport { noop } from '../utils/utils'\nimport {\n  getGenericEventData,\n  getTwoTouchesEventData,\n  getWheelEventValues,\n  supportsGestureEvents,\n  getWebkitGestureEventValues,\n} from '../utils/event'\n\nexport default class PinchRecognizer extends DistanceAngleRecognizer<'pinch'> {\n  ingKey = 'pinching' as IngKey\n\n  constructor(controller: Controller, args: any[]) {\n    super('pinch', controller, args)\n  }\n\n  private pinchShouldStart = (event: UseGestureEvent) => {\n    const { touches } = getGenericEventData(event)\n    return this.enabled && touches === 2\n  }\n\n  onPinchStart = (event: UseGestureEvent<TouchEvent>) => {\n    if (!this.pinchShouldStart(event)) return\n\n    const { values, origin } = getTwoTouchesEventData(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      origin,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchChange = (event: UseGestureEvent<TouchEvent>): void => {\n    const { canceled, timeStamp, _active } = this.state\n    if (canceled || !_active) return\n    const genericEventData = getGenericEventData(event)\n    if (genericEventData.touches !== 2 || event.timeStamp === timeStamp) return\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin } = getTwoTouchesEventData(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      origin,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onPinchEnd = (event: UseGestureEvent): void => {\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      event,\n      ...this.getGenericPayload(event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  onCancel = (): void => {\n    this.state._active = false\n    this.updateGestureState({ canceled: true, cancel: noop })\n    this.updateSharedState({ down: false, touches: 0 })\n\n    requestAnimationFrame(() => this.fireGestureHandler())\n  }\n  /**\n   * PINCH WITH WEBKIT GESTURES\n   */\n\n  onGestureStart = (event: WebKitGestureEvent): void => {\n    if (!this.enabled) return\n    event.preventDefault()\n\n    const { values } = getWebkitGestureEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureChange = (event: WebKitGestureEvent): void => {\n    const { canceled, _active } = this.state\n    if (canceled || !_active) return\n\n    event.preventDefault()\n\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getWebkitGestureEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      cancel: () => this.onCancel(),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onGestureEnd = (event: WebKitGestureEvent): void => {\n    event.preventDefault()\n    if (!this.state.active) return\n    this.state._active = false\n    this.updateSharedState({ down: false, touches: 0 })\n\n    this.updateGestureState({\n      event,\n      ...this.getGenericPayload(event),\n      ...this.getMovement(this.state.values),\n    })\n    this.fireGestureHandler()\n  }\n\n  updateTouchData = (event: UseGestureEvent<TouchEvent>): void => {\n    if (!this.enabled || event.touches.length !== 2 || !this.state._active) return\n    const { origin } = getTwoTouchesEventData(event)\n    this.state.origin = origin\n  }\n\n  /**\n   * PINCH WITH WHEEL\n   */\n  private wheelShouldRun = (event: UseGestureEvent<WheelEvent>) => {\n    return this.enabled && event.ctrlKey\n  }\n\n  private getWheelValuesFromEvent = (event: UseGestureEvent<WheelEvent>) => {\n    const {\n      values: [, delta_d],\n    } = getWheelEventValues(event)\n    const {\n      values: [prev_d, prev_a],\n    } = this.state\n    const d = prev_d - delta_d\n    const a = prev_a !== void 0 ? prev_a : 0\n\n    return {\n      values: [d, a] as Vector2,\n      origin: [event.clientX, event.clientY] as Vector2,\n      delta: [0, delta_d] as Vector2,\n    }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.clearTimeout()\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: UseGestureEvent<WheelEvent>): void => {\n    const { values, delta, origin } = this.getWheelValuesFromEvent(event)\n\n    if (!this.controller.config.eventOptions.passive) {\n      event.preventDefault()\n    } else if (process.env.NODE_ENV === 'development') {\n      console.warn(\n        'To support zoom on trackpads, try using the `domTarget` option and `config.event.passive` set to `false`. This message will only appear in development mode.'\n      )\n    }\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n      offset: values,\n      delta,\n      origin,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: UseGestureEvent<WheelEvent>): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values, origin, delta } = this.getWheelValuesFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n      origin,\n      delta,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState(this.getMovement(this.state.values))\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && supportsGestureEvents()) {\n      this.controller.addBindings('onGestureStart', this.onGestureStart)\n      this.controller.addBindings('onGestureChange', this.onGestureChange)\n      this.controller.addBindings(['onGestureEnd', 'onTouchCancel'], this.onGestureEnd)\n      this.controller.addBindings(['onTouchStart', 'onTouchMove'], this.updateTouchData)\n    } else {\n      this.controller.addBindings('onTouchStart', this.onPinchStart)\n      this.controller.addBindings('onTouchMove', this.onPinchChange)\n      this.controller.addBindings(['onTouchEnd', 'onTouchCancel'], this.onPinchEnd)\n\n      this.controller.addBindings('onWheel', this.onWheel)\n    }\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UsePinchConfig } from '../types'\nimport { getInternalGenericOptions, getInternalDistanceAngleOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Pinch hook.\n *\n * @param {Handler<'pinch'>} handler - the function fired every time the pinch gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and pinch options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function usePinch<Config extends UsePinchConfig>(\n  handler: Handler<'pinch'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...pinch } = config as UsePinchConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    pinch: getInternalDistanceAngleOptions(pinch),\n  }\n\n  return useRecognizers<Config>({ pinch: handler }, [PinchRecognizer], mergedConfig)\n}\n","import { WheelEvent } from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getWheelEventValues, getGenericEventData } from '../utils/event'\nimport { addV, calculateDistance, calculateDirection } from '../utils/math'\n\nexport default class WheelRecognizer extends CoordinatesRecognizer<'wheel'> {\n  ingKey = 'wheeling' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('wheel', controller, args)\n  }\n\n  private wheelShouldRun = (event: UseGestureEvent<WheelEvent>) => {\n    if (event.ctrlKey && 'pinch' in this.controller.handlers) return false\n    return this.enabled\n  }\n\n  private getValuesFromEvent = (event: UseGestureEvent<WheelEvent>) => {\n    const { values: prevValues } = this.state\n    const { values } = getWheelEventValues(event)\n    return { values: addV(values, prevValues) }\n  }\n\n  onWheel = (event: UseGestureEvent<WheelEvent>): void => {\n    if (!this.wheelShouldRun(event)) return\n    this.clearTimeout()\n    this.setTimeout(this.onWheelEnd)\n\n    if (!this.state._active) this.onWheelStart(event)\n    else this.onWheelChange(event)\n  }\n\n  onWheelStart = (event: UseGestureEvent<WheelEvent>): void => {\n    const { values } = this.getValuesFromEvent(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    const movementDetection = this.getMovement(values, startState)\n    const delta = movementDetection.delta!\n\n    this.updateGestureState({\n      ...startState,\n      ...movementDetection,\n      distance: calculateDistance(delta),\n      direction: calculateDirection(delta),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelChange = (event: UseGestureEvent<WheelEvent>): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = this.getValuesFromEvent(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onWheelEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    this.controller.addBindings('onWheel', this.onWheel)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseWheelConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Wheel hook.\n *\n * @param {Handler<'wheel'>} handler - the function fired every time the wheel gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and wheel options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useWheel<Config extends UseWheelConfig>(\n  handler: Handler<'wheel'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...wheel } = config as UseWheelConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    wheel: getInternalCoordinatesOptions(wheel),\n  }\n\n  return useRecognizers<Config>({ wheel: handler }, [WheelRecognizer], mergedConfig)\n}\n","import {} from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getGenericEventData, getPointerEventValues } from '../utils/event'\n\nexport default class MoveRecognizer extends CoordinatesRecognizer<'move'> {\n  ingKey = 'moving' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('move', controller, args)\n  }\n\n  private moveShouldRun = () => {\n    return this.enabled\n  }\n\n  onMove = (event: UseGestureEvent): void => {\n    if (!this.moveShouldRun()) return\n    this.clearTimeout()\n    this.setTimeout(this.onMoveEnd)\n\n    if (!this.state._active) this.onMoveStart(event)\n    else this.onMoveChange(event)\n  }\n\n  onMoveStart = (event: UseGestureEvent): void => {\n    const { values } = getPointerEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n    }\n\n    this.updateGestureState({\n      ...startState,\n      ...this.getMovement(values, startState),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveChange = (event: UseGestureEvent): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getPointerEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onMoveEnd = (): void => {\n    this.state._active = false\n\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  onPointerEnter = (event: UseGestureEvent): void => {\n    this.controller.state.shared.hovering = true\n    if (!this.controller.config.enabled) return\n\n    if (this.controller.config.hover!.enabled) {\n      const { values } = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...this.getGenericPayload(event, true),\n        values,\n        active: true,\n        hovering: true,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n\n    if ('move' in this.controller.handlers) this.onMoveStart(event)\n  }\n\n  onPointerLeave = (event: UseGestureEvent): void => {\n    this.controller.state.shared.hovering = false\n    if ('move' in this.controller.handlers) this.onMoveEnd()\n\n    if (this.controller.config.hover!.enabled) {\n      const { values } = getPointerEventValues(event)\n\n      const state = {\n        ...this.controller.state.shared,\n        ...this.state,\n        ...this.getGenericPayload(event),\n        values,\n        active: false,\n      }\n\n      this.controller.handlers.hover!({ ...state, ...this.mapStateValues(state) })\n    }\n  }\n\n  addBindings(): void {\n    if (this.controller.config.pointer) {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onPointerMove', this.onMove)\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onPointerEnter', this.onPointerEnter)\n        this.controller.addBindings('onPointerLeave', this.onPointerLeave)\n      }\n    } else {\n      if ('move' in this.controller.handlers) {\n        this.controller.addBindings('onMouseMove', this.onMove)\n      }\n      if ('hover' in this.controller.handlers) {\n        this.controller.addBindings('onMouseEnter', this.onPointerEnter)\n        this.controller.addBindings('onMouseLeave', this.onPointerLeave)\n      }\n    }\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseMoveConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Move hook.\n *\n * @param {Handler<'move'>} handler - the function fired every time the move gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and move options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useMove<Config extends UseMoveConfig>(\n  handler: Handler<'move'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...move } = config as UseMoveConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    move: getInternalCoordinatesOptions(move),\n  }\n\n  return useRecognizers<Config>({ move: handler }, [MoveRecognizer], mergedConfig)\n}\n","import useRecognizers from './useRecognizers'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseHoverConfig } from '../types'\nimport { getInternalGenericOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Hover hook.\n *\n * @param {Handler<'hover'>} handler - the function fired every time the hover gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and hover options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useHover<Config extends UseHoverConfig>(\n  handler: Handler<'hover'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...hover } = config as UseHoverConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    hover: { enabled: true, ...hover },\n  }\n\n  return useRecognizers<Config>({ hover: handler }, [MoveRecognizer], mergedConfig)\n}\n","import {} from 'react'\nimport CoordinatesRecognizer from './CoordinatesRecognizer'\nimport Controller from '../Controller'\nimport { UseGestureEvent, IngKey } from '../types'\nimport { getGenericEventData, getScrollEventValues } from '../utils/event'\nimport { calculateDistance, calculateDirection } from '../utils/math'\n\nexport default class ScrollRecognizer extends CoordinatesRecognizer<'scroll'> {\n  ingKey = 'scrolling' as IngKey\n  debounced = true\n\n  constructor(controller: Controller, args: any[]) {\n    super('scroll', controller, args)\n  }\n\n  private scrollShouldRun = () => {\n    return this.enabled\n  }\n\n  onScroll = (event: UseGestureEvent): void => {\n    if (!this.scrollShouldRun()) return\n    this.clearTimeout()\n    this.setTimeout(this.onScrollEnd)\n\n    if (!this.state._active) this.onScrollStart(event)\n    else this.onScrollChange(event)\n  }\n\n  onScrollStart = (event: UseGestureEvent): void => {\n    const { values } = getScrollEventValues(event)\n\n    this.updateSharedState(getGenericEventData(event))\n\n    const startState = {\n      ...this.getStartGestureState(values, event),\n      ...this.getGenericPayload(event, true),\n      initial: this.state.values,\n    }\n\n    const movementDetection = this.getMovement(values, startState)\n    const delta = movementDetection.delta!\n\n    this.updateGestureState({\n      ...startState,\n      ...movementDetection,\n      distance: calculateDistance(delta),\n      direction: calculateDirection(delta),\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onScrollChange = (event: UseGestureEvent): void => {\n    const genericEventData = getGenericEventData(event)\n\n    this.updateSharedState(genericEventData)\n\n    const { values } = getScrollEventValues(event)\n    const kinematics = this.getKinematics(values, event)\n\n    this.updateGestureState({\n      ...this.getGenericPayload(event),\n      ...kinematics,\n    })\n\n    this.fireGestureHandler()\n  }\n\n  onScrollEnd = (): void => {\n    this.state._active = false\n    this.updateGestureState({ ...this.getMovement(this.state.values), velocities: [0, 0], velocity: 0 })\n    this.fireGestureHandler()\n  }\n\n  addBindings(): void {\n    this.controller.addBindings('onScroll', this.onScroll)\n  }\n}\n","import useRecognizers from './useRecognizers'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport { Handler, InternalConfig, HookReturnType, UseScrollConfig } from '../types'\nimport { getInternalGenericOptions, getInternalCoordinatesOptions } from '../utils/config'\n\n/**\n * @public\n *\n * Scroll hook.\n *\n * @param {Handler<'scroll'>} handler - the function fired every time the scroll gesture updates\n * @param {(Config | {})} [config={}] - the config object including generic options and scroll options\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useScroll<Config extends UseScrollConfig>(\n  handler: Handler<'scroll'>,\n  config: Config | {} = {}\n): (...args: any[]) => HookReturnType<Config> {\n  const { domTarget, eventOptions, window, ...scroll } = config as UseScrollConfig\n\n  /**\n   * TODO: at the moment we recompute the config object at every render\n   * this could probably be optimized\n   */\n  const mergedConfig: InternalConfig = {\n    ...getInternalGenericOptions({\n      domTarget,\n      eventOptions,\n      window,\n    }),\n    scroll: getInternalCoordinatesOptions(scroll),\n  }\n\n  return useRecognizers<Config>({ scroll: handler }, [ScrollRecognizer], mergedConfig)\n}\n","import React from 'react'\nimport useRecognizers from './useRecognizers'\nimport DragRecognizer from '../recognizers/DragRecognizer'\nimport WheelRecognizer from '../recognizers/WheelRecognizer'\nimport MoveRecognizer from '../recognizers/MoveRecognizer'\nimport PinchRecognizer from '../recognizers/PinchRecognizer'\nimport ScrollRecognizer from '../recognizers/ScrollRecognizer'\nimport {\n  getInternalGenericOptions,\n  getInternalDragOptions,\n  getInternalCoordinatesOptions,\n  getInternalDistanceAngleOptions,\n} from '../utils/config'\nimport {\n  InternalConfig,\n  HandlerKey,\n  UserHandlersPartial,\n  InternalHandlers,\n  UserHandlers,\n  RecognizerClasses,\n  UseGestureConfig,\n  HookReturnType,\n} from '../types'\n\n/**\n * @public\n *\n * The most complete gesture hook, allowing support for multiple gestures.\n *\n * @param {UserHandlersPartial} handlers - an object with on[Gesture] keys containg gesture handlers\n * @param {UseGestureConfig} [config={}] - the full config object\n * @returns {(...args: any[]) => HookReturnType<Config>}\n */\nexport function useGesture<Config extends UseGestureConfig>(\n  handlers: UserHandlersPartial,\n  config: UseGestureConfig = {}\n): (...args: any[]) => HookReturnType<Config> {\n  /**\n   * If handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n   * actions will include 'onDrag' and 'onMove.\n   */\n  const [actions] = React.useState(() => new Set(Object.keys(handlers).map(k => k.replace(/End|Start/, ''))))\n\n  /**\n   * Here we compute the derived internal config based on the provided config object.\n   * We decompose the config into its generic and gesture options and compute each.\n   * TODO: this is currently done on every render!\n   */\n  const { drag, wheel, move, scroll, pinch, hover, ...restConfig } = config\n\n  const mergedConfig: InternalConfig = getInternalGenericOptions(restConfig)\n\n  const classes: RecognizerClasses = []\n  const internalHandlers: Partial<InternalHandlers> = {}\n\n  // will hold reference to native handlers such as onClick, onMouseDown, etc.\n  const _nativeHandlers = { ...handlers }\n\n  if (actions.has('onDrag')) {\n    classes.push(DragRecognizer)\n    internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag', _nativeHandlers)\n    mergedConfig.drag = getInternalDragOptions(drag)\n  }\n  if (actions.has('onWheel')) {\n    classes.push(WheelRecognizer)\n    internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel', _nativeHandlers)\n    mergedConfig.wheel = getInternalCoordinatesOptions(wheel)\n  }\n  if (actions.has('onScroll')) {\n    classes.push(ScrollRecognizer)\n    internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll', _nativeHandlers)\n    mergedConfig.scroll = getInternalCoordinatesOptions(scroll)\n  }\n  if (actions.has('onMove')) {\n    classes.push(MoveRecognizer)\n    internalHandlers.move = includeStartEndHandlers(handlers, 'onMove', _nativeHandlers)\n    mergedConfig.move = getInternalCoordinatesOptions(move)\n  }\n  if (actions.has('onPinch')) {\n    classes.push(PinchRecognizer)\n    internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch', _nativeHandlers)\n    mergedConfig.pinch = getInternalDistanceAngleOptions(pinch)\n  }\n  if (actions.has('onHover')) {\n    if (!actions.has('onMove')) classes.push(MoveRecognizer)\n    internalHandlers.hover = handlers.onHover\n    mergedConfig.hover = { enabled: true, ...hover }\n    delete _nativeHandlers.onHover\n  }\n\n  return useRecognizers<Config>(internalHandlers, classes, mergedConfig, _nativeHandlers)\n}\n/**\n * @private\n *\n * This utility function will integrate start and end handlers into the regular\n * handler function by using first and last conditions.\n *\n * @param {UserHandlersPartial} handlers - the handlers function object\n * @param {HandlerKey} handlerKey - the key for which to integrate start and end handlers\n * @returns\n */\nfunction includeStartEndHandlers(\n  handlers: UserHandlersPartial,\n  handlerKey: HandlerKey,\n  _nativeHandlers: UserHandlersPartial\n) {\n  const startKey = (handlerKey + 'Start') as keyof UserHandlers\n  const endKey = (handlerKey + 'End') as keyof UserHandlers\n\n  delete _nativeHandlers[handlerKey]\n  delete _nativeHandlers[startKey]\n  delete _nativeHandlers[endKey]\n\n  const fn = (state: any) => {\n    let memo: any = undefined\n    if (state.first && startKey in handlers) handlers[startKey]!(state)\n    if (handlerKey in handlers) memo = handlers[handlerKey]!(state)\n    if (state.last && endKey in handlers) handlers[endKey]!(state)\n    return memo\n  }\n  return fn\n}\n"]},"metadata":{},"sourceType":"module"}